# 采集端注册机制设计

## 1. 问题分析

### 1.1 当前架构问题

**中心端(gravital-core)已实现**:
- ✅ Sentinel 注册 API (`POST /api/v1/sentinels/register`)
- ✅ Sentinel 心跳 API (`POST /api/v1/sentinels/heartbeat`)
- ✅ API Token 生成与验证
- ✅ Sentinel 状态管理

**采集端(orbital-sentinels)缺失**:
- ❌ 没有注册逻辑
- ❌ 没有保存 API Token 机制
- ❌ 没有注册失败重试机制
- ❌ 没有注册状态管理

**当前问题**:
1. 采集端启动时直接使用配置文件中的固定 `sentinel_id` 和 `api_token`
2. 如果 API Token 无效,心跳会一直失败
3. 采集端无法动态注册到中心端
4. 无法实现自动化部署(每个采集端都需要手动配置 Token)

### 1.2 架构师视角的设计思考

作为架构师,我们需要考虑以下几个关键问题:

#### **问题1: 注册时机**
- 采集端第一次启动时注册?
- 每次启动都尝试注册?
- 注册失败如何处理?

#### **问题2: 凭证管理**
- API Token 存储在哪里?
- Token 过期如何处理?
- Token 如何更新?

#### **问题3: 身份识别**
- 如何保证采集端唯一性?
- 如何处理重复注册?
- 如何处理机器重装后的重新注册?

#### **问题4: 容错设计**
- 中心端不可用时如何处理?
- 网络断开时如何处理?
- 注册失败后的降级策略?

#### **问题5: 安全性**
- 如何防止未授权的采集端注册?
- 如何防止 Token 被盗用?
- 如何实现注册审批机制?

---

## 2. 架构设计方案

### 2.1 注册流程设计

```
┌────────────────────────────────────────────────────────────────┐
│                    采集端启动注册流程                            │
└────────────────────────────────────────────────────────────────┘

1. 采集端启动
   ├─> 检查本地是否有有效凭证
   │   ├─> 有 → 使用本地凭证
   │   │   └─> 验证凭证有效性(发送心跳测试)
   │   │       ├─> 有效 → 继续运行
   │   │       └─> 无效 → 重新注册
   │   └─> 无 → 进行注册
   │
2. 注册到中心端
   ├─> 收集设备信息
   │   ├─ Hostname
   │   ├─ IP Address
   │   ├─ OS/Arch
   │   ├─ Version
   │   ├─ Region/Labels
   │   └─ Registration Key (可选,用于准入控制)
   │
   ├─> 调用注册 API
   │   POST /api/v1/sentinels/register
   │   Headers: X-Registration-Key (可选)
   │   Body: {name, hostname, ip, version, os, arch, region, labels}
   │
   ├─> 处理注册响应
   │   ├─ 成功 → 保存凭证到本地
   │   │   ├─ Sentinel ID
   │   │   ├─ API Token
   │   │   └─ 配置信息
   │   │
   │   └─ 失败 → 根据策略处理
   │       ├─ 重试(网络错误)
   │       ├─ 降级为独立模式(中心端不可用)
   │       └─ 退出(授权失败)
   │
3. 继续启动流程
   └─> 使用获取的凭证启动心跳、任务获取等
```

### 2.2 凭证存储方案

#### **方案A: 配置文件存储(推荐)**

```yaml
# ~/.sentinel/credentials.yaml
sentinel_id: "sentinel-host123-1699999999"
api_token: "st_abc123xyz789..."
registered_at: "2025-11-13T10:30:00Z"
core_url: "http://gravital-core:8080"
region: "beijing"
```

**优点**:
- 简单直观,易于调试
- 可以手动编辑和备份
- 跨平台兼容性好

**缺点**:
- 安全性相对较低(明文存储)
- 需要设置合适的文件权限

#### **方案B: 加密存储**

```go
// 使用 AES 加密存储凭证
type EncryptedCredentials struct {
    EncryptedData string `json:"encrypted_data"`
    IV            string `json:"iv"`
    Salt          string `json:"salt"`
}
```

**优点**:
- 安全性高
- 防止 Token 泄露

**缺点**:
- 实现复杂度高
- 需要管理加密密钥

#### **推荐方案: 配置文件 + 文件权限**

```go
// 凭证文件路径
const (
    DefaultCredentialsPath = "/etc/sentinel/credentials.yaml"  // Linux
    DefaultCredentialsPath = "~/.sentinel/credentials.yaml"    // User home
)

// 设置文件权限为 0600 (仅所有者可读写)
os.Chmod(credentialsPath, 0600)
```

### 2.3 身份识别机制

#### **唯一性保证**

采集端的唯一标识基于:

```go
// 生成 Sentinel ID
func GenerateSentinelID() string {
    hostname, _ := os.Hostname()
    mac := getMACAddress()  // 主网卡 MAC 地址
    timestamp := time.Now().Unix()
    
    // sentinel-{hostname}-{mac_hash}-{timestamp}
    return fmt.Sprintf("sentinel-%s-%s-%d", 
        hostname, 
        hashMAC(mac), 
        timestamp)
}
```

**优点**:
- Hostname + MAC 确保物理机唯一性
- Timestamp 处理重装场景

#### **重复注册处理**

中心端策略:
```go
// 检查已存在的 Sentinel
existing := findByHostnameAndMAC(hostname, mac)
if existing != nil {
    // 更新已存在的记录
    existing.Version = newVersion
    existing.Status = "online"
    existing.LastHeartbeat = time.Now()
    return existing.SentinelID, existing.APIToken
}

// 创建新记录
return createNewSentinel(...)
```

### 2.4 容错与降级策略

```
┌────────────────────────────────────────────────────────────────┐
│                    注册失败处理策略                              │
└────────────────────────────────────────────────────────────────┘

注册失败
  ├─> 判断失败原因
  │   ├─ 网络错误 (connection refused, timeout)
  │   │   └─> 重试策略
  │   │       ├─ 第1次: 立即重试
  │   │       ├─ 第2次: 等待 5秒
  │   │       ├─ 第3次: 等待 10秒
  │   │       ├─ 第4次: 等待 30秒
  │   │       └─> 最多重试 5 次
  │   │           ├─ 成功 → 继续运行
  │   │           └─ 失败 → 降级为独立模式
  │   │
  │   ├─ 授权失败 (401, 403)
  │   │   └─> 检查 Registration Key
  │   │       ├─ 有效 → 记录错误,等待管理员审批
  │   │       └─ 无效 → 记录错误,退出程序
  │   │
  │   ├─ 中心端错误 (500, 503)
  │   │   └─> 等待 60秒后重试
  │   │       └─> 最多重试 3 次
  │   │           └─ 失败 → 降级为独立模式
  │   │
  │   └─ 其他错误
  │       └─> 记录错误,降级为独立模式
  │
  └─> 降级为独立模式
      ├─ 使用本地任务配置
      ├─ 使用直连发送器
      └─ 定期尝试重新注册(每5分钟)
```

### 2.5 安全性设计

#### **准入控制(可选)**

```yaml
# 中心端配置
sentinel:
  registration:
    mode: "open"  # open | key | approval
    registration_key: "reg_secret_key_123456"
    auto_approve: false
```

**模式说明**:
- `open`: 允许任何采集端注册
- `key`: 需要提供有效的 Registration Key
- `approval`: 需要管理员手动审批

#### **API Token 管理**

```go
// Token 格式
// st_<random_32_bytes>
// 例: st_a1b2c3d4e5f6789012345678901234567890

// Token 存储
// 中心端: 存储 Token 的 SHA256 哈希值
// 采集端: 存储原始 Token

// Token 验证
func ValidateToken(providedToken string, storedHash string) bool {
    hash := sha256.Sum256([]byte(providedToken))
    return hex.EncodeToString(hash[:]) == storedHash
}
```

#### **Token 轮换机制(可选)**

```go
// 定期轮换 Token (例如: 90天)
type TokenRotation struct {
    CurrentToken  string
    NextToken     string  // 预生成的下一个 Token
    ExpiresAt     time.Time
    GracePeriod   time.Duration  // 宽限期,允许旧 Token 继续使用
}
```

---

## 3. 数据模型设计

### 3.1 采集端凭证模型

```go
// Credentials 采集端凭证
type Credentials struct {
    SentinelID   string    `yaml:"sentinel_id"`
    APIToken     string    `yaml:"api_token"`
    CoreURL      string    `yaml:"core_url"`
    RegisteredAt time.Time `yaml:"registered_at"`
    Region       string    `yaml:"region,omitempty"`
    Labels       map[string]string `yaml:"labels,omitempty"`
}
```

### 3.2 注册请求模型

```go
// RegisterRequest 注册请求
type RegisterRequest struct {
    Name             string                 `json:"name"`              // 显示名称
    Hostname         string                 `json:"hostname"`          // 主机名
    IPAddress        string                 `json:"ip_address"`        // IP地址
    MACAddress       string                 `json:"mac_address"`       // MAC地址
    Version          string                 `json:"version"`           // 版本
    OS               string                 `json:"os"`                // 操作系统
    Arch             string                 `json:"arch"`              // 架构
    Region           string                 `json:"region,omitempty"`  // 区域
    Labels           map[string]interface{} `json:"labels,omitempty"`  // 标签
    RegistrationKey  string                 `json:"registration_key,omitempty"` // 注册密钥
}

// RegisterResponse 注册响应
type RegisterResponse struct {
    SentinelID string                 `json:"sentinel_id"`
    APIToken   string                 `json:"api_token"`
    Config     map[string]interface{} `json:"config"`
    Message    string                 `json:"message,omitempty"`
}
```

### 3.3 中心端数据模型增强

```sql
-- 在现有 sentinels 表基础上增加字段
ALTER TABLE sentinels ADD COLUMN mac_address VARCHAR(17);
ALTER TABLE sentinels ADD COLUMN registration_key_hash VARCHAR(64);
ALTER TABLE sentinels ADD COLUMN approval_status VARCHAR(20) DEFAULT 'approved';
ALTER TABLE sentinels ADD COLUMN approved_by INTEGER;
ALTER TABLE sentinels ADD COLUMN approved_at TIMESTAMP;

-- 创建注册审批记录表(可选)
CREATE TABLE sentinel_registrations (
    id SERIAL PRIMARY KEY,
    hostname VARCHAR(255) NOT NULL,
    ip_address VARCHAR(45),
    mac_address VARCHAR(17),
    version VARCHAR(50),
    os VARCHAR(50),
    arch VARCHAR(20),
    region VARCHAR(100),
    labels JSONB,
    registration_key_hash VARCHAR(64),
    status VARCHAR(20) NOT NULL,  -- pending, approved, rejected
    requested_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    reviewed_by INTEGER,
    reviewed_at TIMESTAMP,
    review_notes TEXT,
    sentinel_id VARCHAR(100),  -- 审批通过后生成
    UNIQUE(hostname, mac_address)
);
```

---

## 4. 实现方案

### 4.1 采集端实现

#### **4.1.1 凭证管理器**

```go
// internal/credentials/manager.go
package credentials

import (
    "fmt"
    "os"
    "path/filepath"
    "gopkg.in/yaml.v3"
)

type Manager struct {
    credentialsPath string
    credentials     *Credentials
}

func NewManager(credentialsPath string) *Manager {
    if credentialsPath == "" {
        credentialsPath = getDefaultCredentialsPath()
    }
    return &Manager{
        credentialsPath: credentialsPath,
    }
}

// Load 加载凭证
func (m *Manager) Load() (*Credentials, error) {
    data, err := os.ReadFile(m.credentialsPath)
    if err != nil {
        if os.IsNotExist(err) {
            return nil, nil  // 文件不存在,返回 nil
        }
        return nil, fmt.Errorf("failed to read credentials: %w", err)
    }

    var creds Credentials
    if err := yaml.Unmarshal(data, &creds); err != nil {
        return nil, fmt.Errorf("failed to unmarshal credentials: %w", err)
    }

    m.credentials = &creds
    return &creds, nil
}

// Save 保存凭证
func (m *Manager) Save(creds *Credentials) error {
    // 确保目录存在
    dir := filepath.Dir(m.credentialsPath)
    if err := os.MkdirAll(dir, 0700); err != nil {
        return fmt.Errorf("failed to create directory: %w", err)
    }

    // 序列化
    data, err := yaml.Marshal(creds)
    if err != nil {
        return fmt.Errorf("failed to marshal credentials: %w", err)
    }

    // 写入文件 (0600权限,仅所有者可读写)
    if err := os.WriteFile(m.credentialsPath, data, 0600); err != nil {
        return fmt.Errorf("failed to write credentials: %w", err)
    }

    m.credentials = creds
    return nil
}

// Delete 删除凭证
func (m *Manager) Delete() error {
    if err := os.Remove(m.credentialsPath); err != nil && !os.IsNotExist(err) {
        return fmt.Errorf("failed to delete credentials: %w", err)
    }
    m.credentials = nil
    return nil
}

// GetCredentials 获取当前凭证
func (m *Manager) GetCredentials() *Credentials {
    return m.credentials
}

func getDefaultCredentialsPath() string {
    // Linux/Mac: ~/.sentinel/credentials.yaml
    // Windows: %USERPROFILE%\.sentinel\credentials.yaml
    home, _ := os.UserHomeDir()
    return filepath.Join(home, ".sentinel", "credentials.yaml")
}
```

#### **4.1.2 注册管理器**

```go
// internal/register/manager.go
package register

import (
    "bytes"
    "context"
    "encoding/json"
    "fmt"
    "io"
    "net"
    "net/http"
    "os"
    "runtime"
    "time"
)

type Manager struct {
    client          *http.Client
    coreURL         string
    registrationKey string
    credentials     *credentials.Manager
}

func NewManager(coreURL, registrationKey string, credsMgr *credentials.Manager) *Manager {
    return &Manager{
        client: &http.Client{
            Timeout: 30 * time.Second,
        },
        coreURL:         coreURL,
        registrationKey: registrationKey,
        credentials:     credsMgr,
    }
}

// Register 注册到中心端
func (m *Manager) Register(ctx context.Context, config *Config) (*RegisterResponse, error) {
    // 1. 收集设备信息
    req, err := m.buildRegisterRequest(config)
    if err != nil {
        return nil, fmt.Errorf("failed to build register request: %w", err)
    }

    // 2. 发送注册请求
    resp, err := m.sendRegisterRequest(ctx, req)
    if err != nil {
        return nil, fmt.Errorf("failed to send register request: %w", err)
    }

    // 3. 保存凭证
    creds := &credentials.Credentials{
        SentinelID:   resp.SentinelID,
        APIToken:     resp.APIToken,
        CoreURL:      m.coreURL,
        RegisteredAt: time.Now(),
        Region:       config.Region,
        Labels:       config.Labels,
    }

    if err := m.credentials.Save(creds); err != nil {
        return nil, fmt.Errorf("failed to save credentials: %w", err)
    }

    return resp, nil
}

// RegisterWithRetry 带重试的注册
func (m *Manager) RegisterWithRetry(ctx context.Context, config *Config) (*RegisterResponse, error) {
    retryIntervals := []time.Duration{
        0,              // 立即尝试
        5 * time.Second,
        10 * time.Second,
        30 * time.Second,
        60 * time.Second,
    }

    var lastErr error
    for i, interval := range retryIntervals {
        if i > 0 {
            logger.Info("Retrying registration", 
                zap.Int("attempt", i+1),
                zap.Duration("wait", interval))
            
            select {
            case <-time.After(interval):
            case <-ctx.Done():
                return nil, ctx.Err()
            }
        }

        resp, err := m.Register(ctx, config)
        if err == nil {
            return resp, nil
        }

        lastErr = err
        logger.Warn("Registration failed",
            zap.Int("attempt", i+1),
            zap.Error(err))
    }

    return nil, fmt.Errorf("registration failed after %d attempts: %w", 
        len(retryIntervals), lastErr)
}

// buildRegisterRequest 构建注册请求
func (m *Manager) buildRegisterRequest(config *Config) (*RegisterRequest, error) {
    hostname, _ := os.Hostname()
    ipAddress := getLocalIP()
    macAddress := getMACAddress()

    return &RegisterRequest{
        Name:            config.Name,
        Hostname:        hostname,
        IPAddress:       ipAddress,
        MACAddress:      macAddress,
        Version:         config.Version,
        OS:              runtime.GOOS,
        Arch:            runtime.GOARCH,
        Region:          config.Region,
        Labels:          config.Labels,
        RegistrationKey: m.registrationKey,
    }, nil
}

// sendRegisterRequest 发送注册请求
func (m *Manager) sendRegisterRequest(ctx context.Context, req *RegisterRequest) (*RegisterResponse, error) {
    data, err := json.Marshal(req)
    if err != nil {
        return nil, fmt.Errorf("failed to marshal request: %w", err)
    }

    httpReq, err := http.NewRequestWithContext(
        ctx,
        "POST",
        m.coreURL+"/api/v1/sentinels/register",
        bytes.NewReader(data),
    )
    if err != nil {
        return nil, fmt.Errorf("failed to create request: %w", err)
    }

    httpReq.Header.Set("Content-Type", "application/json")
    if m.registrationKey != "" {
        httpReq.Header.Set("X-Registration-Key", m.registrationKey)
    }

    httpResp, err := m.client.Do(httpReq)
    if err != nil {
        return nil, fmt.Errorf("failed to send request: %w", err)
    }
    defer httpResp.Body.Close()

    body, _ := io.ReadAll(httpResp.Body)

    if httpResp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("registration failed: status=%d, body=%s", 
            httpResp.StatusCode, string(body))
    }

    var apiResp struct {
        Code int              `json:"code"`
        Data RegisterResponse `json:"data"`
    }

    if err := json.Unmarshal(body, &apiResp); err != nil {
        return nil, fmt.Errorf("failed to unmarshal response: %w", err)
    }

    if apiResp.Code != 0 {
        return nil, fmt.Errorf("registration failed: code=%d", apiResp.Code)
    }

    return &apiResp.Data, nil
}

// 获取本地 IP 地址
func getLocalIP() string {
    addrs, err := net.InterfaceAddrs()
    if err != nil {
        return ""
    }

    for _, addr := range addrs {
        if ipnet, ok := addr.(*net.IPNet); ok && !ipnet.IP.IsLoopback() {
            if ipnet.IP.To4() != nil {
                return ipnet.IP.String()
            }
        }
    }
    return ""
}

// 获取 MAC 地址
func getMACAddress() string {
    interfaces, err := net.Interfaces()
    if err != nil {
        return ""
    }

    for _, iface := range interfaces {
        // 跳过 loopback 和 down 的接口
        if iface.Flags&net.FlagLoopback != 0 || iface.Flags&net.FlagUp == 0 {
            continue
        }
        
        if len(iface.HardwareAddr) > 0 {
            return iface.HardwareAddr.String()
        }
    }
    return ""
}
```

#### **4.1.3 Agent 启动流程整合**

```go
// internal/agent/agent.go
func (a *Agent) Start() error {
    a.ctx, a.cancel = context.WithCancel(context.Background())

    // 1. 初始化凭证管理器
    credsMgr := credentials.NewManager(a.config.CredentialsPath)
    
    // 2. 尝试加载本地凭证
    creds, err := credsMgr.Load()
    if err != nil {
        return fmt.Errorf("failed to load credentials: %w", err)
    }

    // 3. 如果没有凭证,进行注册
    if creds == nil || creds.SentinelID == "" {
        logger.Info("No valid credentials found, registering to core...")
        
        registerMgr := register.NewManager(
            a.config.Core.URL,
            a.config.Core.RegistrationKey,
            credsMgr,
        )

        registerConfig := &register.Config{
            Name:    a.config.Sentinel.Name,
            Version: version,  // 从编译时注入
            Region:  a.config.Sentinel.Region,
            Labels:  a.config.Sentinel.Labels,
        }

        resp, err := registerMgr.RegisterWithRetry(a.ctx, registerConfig)
        if err != nil {
            logger.Warn("Failed to register to core, falling back to standalone mode",
                zap.Error(err))
            // 降级为独立模式
            a.config.Sender.Mode = "direct"
        } else {
            logger.Info("Successfully registered to core",
                zap.String("sentinel_id", resp.SentinelID))
            creds = credsMgr.GetCredentials()
        }
    } else {
        logger.Info("Using existing credentials",
            zap.String("sentinel_id", creds.SentinelID))
        
        // 验证凭证有效性
        if !a.validateCredentials(creds) {
            logger.Warn("Credentials validation failed, re-registering...")
            // 删除旧凭证并重新注册
            credsMgr.Delete()
            // TODO: 重新注册
        }
    }

    // 4. 使用凭证初始化组件
    if creds != nil {
        a.config.Sentinel.ID = creds.SentinelID
        a.config.Core.APIToken = creds.APIToken
    }

    // 5. 继续原有的初始化流程
    if err := a.initialize(); err != nil {
        return fmt.Errorf("failed to initialize: %w", err)
    }

    // 6. 启动各组件
    a.setState(StateRunning)
    a.startComponents()

    // 7. 监听信号
    a.handleSignals()

    return nil
}

// validateCredentials 验证凭证有效性
func (a *Agent) validateCredentials(creds *credentials.Credentials) bool {
    // 发送一次心跳测试
    client := &http.Client{Timeout: 10 * time.Second}
    
    req, _ := http.NewRequest("POST", 
        creds.CoreURL+"/api/v1/sentinels/heartbeat",
        bytes.NewReader([]byte("{}")))
    
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("X-Sentinel-ID", creds.SentinelID)
    req.Header.Set("X-API-Token", creds.APIToken)

    resp, err := client.Do(req)
    if err != nil {
        return false
    }
    defer resp.Body.Close()

    return resp.StatusCode == http.StatusOK
}
```

### 4.2 中心端增强

#### **4.2.1 注册 Service 增强**

```go
// internal/service/sentinel_service.go

// 在 RegisterSentinelRequest 中增加字段
type RegisterSentinelRequest struct {
    Name             string                 `json:"name" binding:"required"`
    Hostname         string                 `json:"hostname" binding:"required"`
    IPAddress        string                 `json:"ip_address"`
    MACAddress       string                 `json:"mac_address"`      // 新增
    Version          string                 `json:"version" binding:"required"`
    OS               string                 `json:"os" binding:"required"`
    Arch             string                 `json:"arch" binding:"required"`
    Region           string                 `json:"region"`
    Labels           map[string]interface{} `json:"labels"`
    RegistrationKey  string                 `json:"registration_key"` // 新增
}

// Register 方法增强
func (s *sentinelService) Register(ctx context.Context, req *RegisterSentinelRequest) (*RegisterSentinelResponse, error) {
    // 1. 验证 Registration Key (如果启用)
    if s.config.RegistrationMode == "key" || s.config.RegistrationMode == "approval" {
        if !s.validateRegistrationKey(req.RegistrationKey) {
            return nil, fmt.Errorf("invalid registration key")
        }
    }

    // 2. 检查是否需要审批
    if s.config.RegistrationMode == "approval" && !s.config.AutoApprove {
        // 创建待审批记录
        return s.createPendingRegistration(ctx, req)
    }

    // 3. 基于 Hostname + MAC 检查是否已存在
    var existing *model.Sentinel
    if req.MACAddress != "" {
        existing, _ = s.sentinelRepo.GetByHostnameAndMAC(ctx, req.Hostname, req.MACAddress)
    } else {
        existing, _ = s.sentinelRepo.GetByHostname(ctx, req.Hostname)
    }

    now := time.Now()

    if existing != nil {
        // 4. 更新已存在的 Sentinel
        logger.Info("Updating existing sentinel",
            zap.String("sentinel_id", existing.SentinelID),
            zap.String("hostname", req.Hostname))

        existing.Name = req.Name
        existing.IPAddress = req.IPAddress
        existing.Version = req.Version
        existing.OS = req.OS
        existing.Arch = req.Arch
        existing.Region = req.Region
        existing.Labels = req.Labels
        existing.Status = "online"
        existing.LastHeartbeat = &now
        existing.UpdatedAt = now

        if err := s.sentinelRepo.Update(ctx, existing); err != nil {
            return nil, fmt.Errorf("failed to update sentinel: %w", err)
        }

        return &RegisterSentinelResponse{
            SentinelID: existing.SentinelID,
            APIToken:   existing.APIToken,
            Config: map[string]interface{}{
                "heartbeat_interval": 30,
                "task_fetch_interval": 60,
            },
            Message: "Sentinel re-registered successfully",
        }, nil
    }

    // 5. 生成新的 Sentinel ID 和 API Token
    sentinelID := generateSentinelID(req.Hostname, req.MACAddress)
    apiToken, err := generateAPIToken()
    if err != nil {
        return nil, fmt.Errorf("failed to generate api token: %w", err)
    }

    // 6. 创建新的 Sentinel
    sentinel := &model.Sentinel{
        SentinelID:    sentinelID,
        Name:          req.Name,
        Hostname:      req.Hostname,
        IPAddress:     req.IPAddress,
        MACAddress:    req.MACAddress,
        Version:       req.Version,
        OS:            req.OS,
        Arch:          req.Arch,
        Region:        req.Region,
        Labels:        req.Labels,
        APIToken:      hashAPIToken(apiToken),  // 存储哈希值
        Status:        "online",
        LastHeartbeat: &now,
        RegisteredAt:  now,
        UpdatedAt:     now,
    }

    if err := s.sentinelRepo.Create(ctx, sentinel); err != nil {
        return nil, fmt.Errorf("failed to create sentinel: %w", err)
    }

    logger.Info("New sentinel registered",
        zap.String("sentinel_id", sentinelID),
        zap.String("hostname", req.Hostname))

    return &RegisterSentinelResponse{
        SentinelID: sentinelID,
        APIToken:   apiToken,  // 返回原始 Token
        Config: map[string]interface{}{
            "heartbeat_interval": 30,
            "task_fetch_interval": 60,
        },
        Message: "Sentinel registered successfully",
    }, nil
}

// generateSentinelID 生成 Sentinel ID
func generateSentinelID(hostname, mac string) string {
    timestamp := time.Now().Unix()
    if mac != "" {
        // 使用 MAC 地址的哈希值
        macHash := fmt.Sprintf("%x", md5.Sum([]byte(mac)))[:8]
        return fmt.Sprintf("sentinel-%s-%s-%d", hostname, macHash, timestamp)
    }
    return fmt.Sprintf("sentinel-%s-%d", hostname, timestamp)
}

// hashAPIToken 哈希 API Token
func hashAPIToken(token string) string {
    hash := sha256.Sum256([]byte(token))
    return hex.EncodeToString(hash[:])
}
```

---

## 5. 部署与配置

### 5.1 采集端配置

```yaml
# config/config.yaml
sentinel:
  name: "sentinel-office-1"
  region: "beijing"
  labels:
    environment: "production"
    datacenter: "dc1"

core:
  url: "http://gravital-core:8080"
  registration_key: "reg_secret_key_123456"  # 可选,用于准入控制
  
# 凭证文件路径(可选,默认: ~/.sentinel/credentials.yaml)
credentials_path: "/etc/sentinel/credentials.yaml"
```

### 5.2 中心端配置

```yaml
# config/config.yaml
sentinel:
  registration:
    mode: "open"  # open | key | approval
    registration_key: "reg_secret_key_123456"
    auto_approve: false
    
    # Token 配置
    token:
      prefix: "st_"
      length: 32
      hash_algorithm: "sha256"
```

### 5.3 首次部署流程

```bash
# 1. 部署中心端
cd gravital-core
docker-compose up -d

# 2. 部署采集端(自动注册)
cd orbital-sentinels
./bin/sentinel start -c config/config.yaml

# 3. 查看注册状态
./bin/sentinel status

# 4. 手动重新注册(如果需要)
./bin/sentinel register --force
```

---

## 6. 运维管理

### 6.1 CLI 命令增强

```bash
# 查看当前凭证状态
sentinel credentials show

# 验证凭证有效性
sentinel credentials validate

# 删除凭证(重新注册)
sentinel credentials delete

# 手动注册
sentinel register

# 强制重新注册
sentinel register --force
```

### 6.2 故障排查

**问题1: 注册失败**
```bash
# 检查网络连接
curl -v http://gravital-core:8080/api/v1/health

# 查看注册日志
tail -f logs/sentinel.log | grep register

# 手动测试注册 API
curl -X POST http://gravital-core:8080/api/v1/sentinels/register \
  -H "Content-Type: application/json" \
  -H "X-Registration-Key: reg_secret_key_123456" \
  -d '{
    "name": "test-sentinel",
    "hostname": "test-host",
    "version": "1.0.0",
    "os": "linux",
    "arch": "amd64"
  }'
```

**问题2: Token 无效**
```bash
# 删除旧凭证
rm ~/.sentinel/credentials.yaml

# 重启采集端(自动重新注册)
./bin/sentinel start
```

**问题3: 中心端不可用**
```bash
# 采集端会自动降级为独立模式
# 查看日志确认
tail -f logs/sentinel.log | grep "standalone mode"
```

---

## 7. 架构优势总结

### 7.1 解决的问题

✅ **自动化部署**: 采集端启动时自动注册,无需手动配置 Token  
✅ **身份管理**: 基于 Hostname + MAC 的唯一性保证  
✅ **安全性**: Token 哈希存储,可选的准入控制  
✅ **容错性**: 注册失败自动降级为独立模式  
✅ **可维护性**: 凭证本地持久化,重启后自动恢复  
✅ **灵活性**: 支持多种注册模式(open/key/approval)  

### 7.2 架构特点

- **渐进式增强**: 采集端可以独立运行,也可以注册到中心端
- **失败降级**: 中心端不可用时自动降级为独立模式
- **状态持久化**: 凭证本地存储,避免重复注册
- **身份唯一性**: 基于硬件特征(MAC)保证身份唯一
- **安全可控**: 可选的准入控制和审批机制

### 7.3 未来扩展

- **Token 自动轮换**: 定期更新 Token 提高安全性
- **多中心端支持**: 采集端可以注册到多个中心端
- **动态配置下发**: 注册时从中心端获取配置
- **审批工作流**: 管理员审批注册请求
- **监控告警**: 注册失败/Token 过期告警

---

## 8. 总结

作为架构师,在设计采集端注册机制时,需要综合考虑:

1. **功能完整性**: 不仅要有注册 API,还要有完整的注册流程
2. **容错性**: 中心端不可用时系统应能正常工作
3. **安全性**: Token 管理、准入控制、审批机制
4. **可运维性**: 便于部署、故障排查、凭证管理
5. **扩展性**: 为未来的需求留有扩展空间

这个设计方案提供了一个完整的、生产可用的采集端注册机制,既满足了自动化部署的需求,又保证了系统的安全性和可靠性。

