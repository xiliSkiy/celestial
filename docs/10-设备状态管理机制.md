# 设备状态管理机制详解

> 本文档详细说明设备状态（status）字段的来源、更新机制和设计方案。

## 1. 设备状态概述

### 1.1 状态定义

设备的 `status` 字段有以下几种取值：

| 状态 | 说明 | 何时出现 |
|-----|------|---------|
| `unknown` | 未知状态 | 设备刚录入时的初始状态 |
| `online` | 在线 | 设备可达，采集成功 |
| `offline` | 离线 | 设备不可达，采集失败 |
| `error` | 错误 | 设备存在异常（如配置错误） |

### 1.2 数据模型

```go
// gravital-core/internal/model/device.go
type Device struct {
    ID               uint           `gorm:"primaryKey" json:"id"`
    DeviceID         string         `gorm:"uniqueIndex;size:64;not null" json:"device_id"`
    Name             string         `gorm:"size:255;not null" json:"name"`
    DeviceType       string         `gorm:"size:64;not null;index" json:"device_type"`
    Status           string         `gorm:"size:32;default:'unknown';index" json:"status"`
    LastSeen         *time.Time     `json:"last_seen"`
    CreatedAt        time.Time      `json:"created_at"`
    UpdatedAt        time.Time      `json:"updated_at"`
}
```

---

## 2. 当前实现状态

### 2.1 设备录入时

**位置**: `gravital-core/internal/service/device_service.go`

```go
func (s *deviceService) Create(ctx context.Context, req *CreateDeviceRequest) (*model.Device, error) {
    device := &model.Device{
        DeviceID:         deviceID,
        Name:             req.Name,
        DeviceType:       req.DeviceType,
        ConnectionConfig: req.ConnectionConfig,
        Status:           "unknown",  // ✅ 初始状态设置为 unknown
    }
    
    if err := s.deviceRepo.Create(ctx, device); err != nil {
        return nil, fmt.Errorf("failed to create device: %w", err)
    }
    
    return device, nil
}
```

**结论**: 设备录入时，`status` 被硬编码为 `"unknown"`。

### 2.2 当前缺失的功能

⚠️ **问题**: 目前系统**没有实现**设备状态的自动更新机制！

检查代码后发现：
1. ❌ 采集端采集成功后，**没有**更新设备状态为 `online`
2. ❌ 采集端采集失败后，**没有**更新设备状态为 `offline`
3. ❌ 中心端接收数据后，**没有**更新设备的 `last_seen` 时间
4. ❌ 没有定时任务检查设备是否长时间未上报数据

**对比**: 只有 Sentinel（采集端）的状态会自动更新：

```go
// gravital-core/internal/repository/sentinel_repository.go
func (r *sentinelRepository) UpdateHeartbeat(ctx context.Context, sentinelID string, heartbeat *model.SentinelHeartbeat) error {
    // 更新 Sentinel 的最后心跳时间
    now := time.Now()
    return r.db.WithContext(ctx).Model(&model.Sentinel{}).
        Where("sentinel_id = ?", sentinelID).
        Updates(map[string]interface{}{
            "last_heartbeat": now,
            "status":         "online",  // ✅ Sentinel 会自动更新为 online
            "updated_at":     now,
        }).Error
}
```

---

## 3. 设备状态更新方案设计

### 3.1 方案对比

#### 方案 1：PostgreSQL 存储 + 采集端上报

**流程**:
```
采集端执行任务 → 采集成功/失败 → 上报数据时携带状态 → 中心端更新 PostgreSQL
```

**优点**:
- ✅ 实时性高，采集结果立即反映
- ✅ 实现简单，只需修改上报接口
- ✅ 无需额外的定时任务
- ✅ 支持复杂查询（如按状态筛选设备）

**缺点**:
- ❌ 依赖采集端上报，如果采集端挂了无法感知
- ❌ 状态数据和指标数据分离存储

#### 方案 2：PostgreSQL 存储 + 中心端定时检查

**流程**:
```
中心端定时任务 → 检查 last_seen 时间 → 超时未上报 → 标记为 offline
```

**优点**:
- ✅ 可以检测采集端挂掉的情况
- ✅ 统一管理，逻辑集中

**缺点**:
- ❌ 有延迟，需要等待定时任务执行
- ❌ 需要额外的定时任务资源

#### 方案 3：时序数据库存储（新方案）⭐

**流程**:
```
采集端执行任务 → 生成状态指标 → 上报到时序库 → 前端查询时序库获取最新状态
```

**数据格式**:
```promql
# 设备在线状态指标（1=online, 0=offline）
device_status{device_id="dev-25422c94", device_type="server"} 1

# 设备最后上报时间戳
device_last_seen{device_id="dev-25422c94"} 1700500000
```

**优点**:
- ✅ 状态和指标数据统一存储，架构一致
- ✅ 天然支持历史状态查询和趋势分析
- ✅ 可以用 PromQL 灵活查询（如：5分钟内未上报的设备）
- ✅ 无需修改数据库表结构
- ✅ 支持状态变更告警（使用 vmalert）

**缺点**:
- ❌ 设备列表页查询性能较差（需要查询时序库）
- ❌ 不支持复杂的关联查询（如按设备组筛选）
- ❌ 时序库不适合存储元数据
- ❌ 需要定期写入心跳数据，增加存储成本

#### 方案 4：混合方案（推荐）⭐⭐⭐

**结合 PostgreSQL 和时序数据库的优势**:

1. **PostgreSQL 存储**（元数据）:
   - 设备基本信息（name, type, config）
   - 当前状态（status）和最后上报时间（last_seen）
   - 用于设备列表、筛选、关联查询

2. **时序数据库存储**（历史数据）:
   - 设备状态历史（device_status 指标）
   - 用于状态趋势分析、可用性统计、告警

3. **更新机制**:
   - 采集端上报时同时更新 PostgreSQL 和时序库
   - 中心端定时检查 PostgreSQL 作为兜底

---

## 4. 方案详细对比分析

### 4.1 纯时序库方案的深入分析

#### 4.1.1 实现方式

**采集端生成状态指标**:

```go
// orbital-sentinels/internal/scheduler/scheduler.go
func (s *Scheduler) runTask(st *ScheduledTask) {
    metrics, err := p.Collect(taskCtx, st.Task)
    
    // 生成设备状态指标
    statusMetric := &plugin.Metric{
        Name:      "device_status",
        Value:     1.0,  // 1=online, 0=offline
        Timestamp: time.Now().UnixMilli(),
        Labels: map[string]string{
            "device_id":   st.Task.DeviceID,
            "device_type": st.Task.DeviceType,
            "sentinel_id": s.sentinelID,
        },
    }
    
    if err != nil {
        statusMetric.Value = 0.0  // 采集失败，标记为离线
    }
    
    // 添加到指标列表
    metrics = append(metrics, statusMetric)
    
    // 上报到时序库
    s.onMetrics(metrics, st.Task)
}
```

**前端查询设备状态**:

```typescript
// 查询设备当前状态
const fetchDeviceStatus = async (deviceId: string) => {
  const res = await metricsApi.queryCurrent(
    `device_status{device_id="${deviceId}"}`
  )
  
  // 解析结果
  const value = parseFloat(res.data.result[0].value[1])
  const status = value === 1 ? 'online' : 'offline'
  
  return status
}

// 查询所有设备状态
const fetchAllDeviceStatus = async () => {
  const res = await metricsApi.queryCurrent('device_status')
  
  const statusMap = {}
  res.data.result.forEach(item => {
    const deviceId = item.metric.device_id
    const value = parseFloat(item.value[1])
    statusMap[deviceId] = value === 1 ? 'online' : 'offline'
  })
  
  return statusMap
}
```

**检测长时间未上报的设备**:

```promql
# 查询 5 分钟内没有上报数据的设备
time() - device_last_seen > 300

# 或者使用 absent_over_time
absent_over_time(device_status[5m])
```

#### 4.1.2 优势场景

**1. 状态历史分析**

```promql
# 查询设备过去 24 小时的在线率
avg_over_time(device_status{device_id="dev-25422c94"}[24h]) * 100

# 查询设备状态变更次数（在线/离线切换）
changes(device_status{device_id="dev-25422c94"}[24h])

# 查询设备离线时长
count_over_time((device_status{device_id="dev-25422c94"} == 0)[24h:1m])
```

**2. 告警规则**

```yaml
# vmalert 告警规则
groups:
  - name: device_status
    rules:
      # 设备离线告警
      - alert: DeviceOffline
        expr: device_status == 0
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "设备 {{ $labels.device_id }} 离线"
          
      # 设备频繁离线告警
      - alert: DeviceFlapping
        expr: changes(device_status[1h]) > 10
        labels:
          severity: warning
        annotations:
          summary: "设备 {{ $labels.device_id }} 频繁离线"
```

**3. 可用性统计**

```promql
# 计算设备 SLA（过去 30 天）
avg_over_time(device_status{device_id="dev-25422c94"}[30d]) * 100

# 按设备类型统计在线率
avg(device_status) by (device_type) * 100
```

#### 4.1.3 劣势场景

**1. 设备列表查询性能问题**

```typescript
// ❌ 性能差：需要查询两个数据源
async function fetchDeviceList() {
  // 1. 从 PostgreSQL 获取设备列表
  const devices = await deviceApi.getDevices({ page: 1, size: 20 })
  
  // 2. 从时序库获取每个设备的状态（N+1 查询问题）
  for (const device of devices) {
    const status = await fetchDeviceStatus(device.device_id)
    device.status = status
  }
  
  return devices
}

// ✅ 优化：批量查询所有设备状态
async function fetchDeviceList() {
  const devices = await deviceApi.getDevices({ page: 1, size: 20 })
  
  // 一次查询所有设备状态
  const statusMap = await fetchAllDeviceStatus()
  
  devices.forEach(device => {
    device.status = statusMap[device.device_id] || 'unknown'
  })
  
  return devices
}
```

**2. 复杂筛选查询困难**

```typescript
// ❌ 无法直接实现：按状态筛选设备
// 需求：查询所有离线的服务器类型设备，且属于生产环境分组
const offlineDevices = await deviceApi.getDevices({
  status: 'offline',
  device_type: 'server',
  group_id: 'prod-group'
})

// 使用时序库方案需要：
// 1. 先从时序库查询所有离线设备的 device_id
// 2. 再从 PostgreSQL 查询这些设备的详细信息
// 3. 在应用层进行过滤
```

**3. 存储成本增加**

```
假设：
- 1000 台设备
- 每 60 秒采集一次
- 每次生成 1 个状态指标

每天数据量：
1000 设备 × (24×60÷60) 次 × 1 指标 = 24,000 个数据点/天

一年数据量：
24,000 × 365 = 8,760,000 个数据点

如果保留 90 天：
24,000 × 90 = 2,160,000 个数据点

相比 PostgreSQL 只存储一条记录，时序库需要存储大量历史数据。
```

### 4.2 混合方案的最佳实践

#### 4.2.1 数据分工

| 数据类型 | PostgreSQL | 时序数据库 | 说明 |
|---------|-----------|-----------|------|
| **设备基本信息** | ✅ 主存储 | ❌ 不存储 | name, type, config 等 |
| **当前状态** | ✅ 主存储 | ✅ 同步存储 | 用于快速查询 |
| **状态历史** | ❌ 不存储 | ✅ 主存储 | 用于趋势分析 |
| **最后上报时间** | ✅ 主存储 | ✅ 同步存储 | 用于超时检测 |

#### 4.2.2 实现架构

```
┌─────────────────────────────────────────────────────────────────┐
│ 采集端 (Orbital Sentinel)                                        │
│                                                                  │
│  ┌──────────────┐                                               │
│  │  Scheduler   │  执行采集任务                                  │
│  └──────┬───────┘                                               │
│         │                                                        │
│         ▼                                                        │
│  ┌──────────────┐                                               │
│  │   Plugin     │  采集指标 + 生成状态指标                        │
│  └──────┬───────┘                                               │
│         │                                                        │
│         ▼                                                        │
│  ┌──────────────┐                                               │
│  │   Sender     │  批量发送                                      │
│  └──────┬───────┘                                               │
└─────────┼────────────────────────────────────────────────────────┘
          │
          │ POST /api/v1/data/ingest
          │ {
          │   "metrics": [...],
          │   "device_status": {...}
          │ }
          │
          ▼
┌─────────────────────────────────────────────────────────────────┐
│ 中心端 (Gravital Core)                                           │
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ ForwarderHandler.IngestMetrics()                          │  │
│  │                                                            │  │
│  │  1. 解压和解析数据                                          │  │
│  │  2. 更新 PostgreSQL 设备状态 ────────┐                     │  │
│  │  3. 转发指标到时序库（包含状态指标）  │                     │  │
│  └────────────────────────────────┬─────┴─────────────────────┘  │
│                                   │                              │
│         ┌─────────────────────────┼──────────────────────┐      │
│         │                         │                      │      │
│         ▼                         ▼                      ▼      │
│  ┌─────────────┐          ┌─────────────┐       ┌─────────────┐│
│  │ PostgreSQL  │          │ VictoriaMetrics│     │ DeviceMonitor││
│  │             │          │             │       │             ││
│  │ devices     │          │ device_status│     │ 定时检查     ││
│  │ ├─status    │          │ ├─value=1   │       │ (兜底机制)  ││
│  │ └─last_seen │          │ └─timestamp │       │             ││
│  └─────────────┘          └─────────────┘       └─────────────┘│
│         │                         │                      │      │
│         │                         │                      │      │
└─────────┼─────────────────────────┼──────────────────────┼──────┘
          │                         │                      │
          │                         │                      │
          ▼                         ▼                      ▼
┌─────────────────────────────────────────────────────────────────┐
│ 前端 (Web UI)                                                    │
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ 设备列表页面                                               │  │
│  │                                                            │  │
│  │  GET /api/v1/devices?status=online                        │  │
│  │  └─> 直接从 PostgreSQL 查询（快速）                        │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ 设备详情页面 - 状态历史                                    │  │
│  │                                                            │  │
│  │  POST /api/v1/metrics/query_range                         │  │
│  │  query: device_status{device_id="dev-xxx"}[24h]          │  │
│  │  └─> 从时序库查询历史（灵活）                              │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

#### 4.2.3 代码实现

**采集端生成状态指标**:

```go
// orbital-sentinels/internal/scheduler/scheduler.go
func (s *Scheduler) runTask(st *ScheduledTask) {
    metrics, err := p.Collect(taskCtx, st.Task)
    
    // 生成设备状态指标（用于时序库）
    statusMetric := &plugin.Metric{
        Name:      "device_status",
        Value:     1.0,
        Timestamp: time.Now().UnixMilli(),
        Labels: map[string]string{
            "device_id":   st.Task.DeviceID,
            "device_type": getDeviceType(st.Task),
        },
    }
    
    if err != nil {
        statusMetric.Value = 0.0
    }
    
    metrics = append(metrics, statusMetric)
    
    // 调用指标处理器（会同时更新 PostgreSQL 和时序库）
    if s.onMetrics != nil {
        s.onMetrics(metrics, st.Task)
    }
}
```

**中心端同时更新两个存储**:

```go
// gravital-core/internal/api/handler/forwarder_handler.go
func (h *ForwarderHandler) IngestMetrics(c *gin.Context) {
    // 1. 解析数据
    var req struct {
        Metrics []*forwarder.Metric `json:"metrics"`
    }
    json.NewDecoder(reader).Decode(&req)
    
    // 2. 提取设备状态信息
    deviceStatusMap := extractDeviceStatus(req.Metrics)
    
    // 3. 更新 PostgreSQL（快速查询）
    if len(deviceStatusMap) > 0 {
        h.updateDeviceStatusInDB(c.Request.Context(), deviceStatusMap)
    }
    
    // 4. 转发到时序库（包含状态指标，用于历史分析）
    if err := h.service.IngestMetrics(c.Request.Context(), req.Metrics); err != nil {
        ErrorResponse(c, http.StatusInternalServerError, 10001, err.Error())
        return
    }
    
    SuccessResponse(c, gin.H{"received": len(req.Metrics)})
}

// 从指标中提取设备状态
func extractDeviceStatus(metrics []*forwarder.Metric) map[string]DeviceStatusInfo {
    statusMap := make(map[string]DeviceStatusInfo)
    
    for _, m := range metrics {
        if m.Name == "device_status" {
            deviceID := m.Labels["device_id"]
            status := "offline"
            if m.Value == 1.0 {
                status = "online"
            }
            
            statusMap[deviceID] = DeviceStatusInfo{
                Status:   status,
                LastSeen: time.UnixMilli(m.Timestamp),
            }
        }
    }
    
    return statusMap
}
```

**前端查询策略**:

```typescript
// 设备列表：从 PostgreSQL 查询（快速）
const fetchDeviceList = async (params: DeviceQuery) => {
  const res = await deviceApi.getDevices(params)
  // 设备状态已经包含在响应中
  return res
}

// 设备详情 - 状态历史：从时序库查询（灵活）
const fetchDeviceStatusHistory = async (deviceId: string) => {
  const now = Math.floor(Date.now() / 1000)
  const start = now - 24 * 3600  // 过去 24 小时
  
  const res = await metricsApi.queryRange({
    query: `device_status{device_id="${deviceId}"}`,
    start,
    end: now,
    step: '60s'
  })
  
  // 渲染状态趋势图
  return res.data.result[0].values
}

// 设备详情 - 在线率统计：从时序库查询
const fetchDeviceUptime = async (deviceId: string) => {
  const res = await metricsApi.queryCurrent(
    `avg_over_time(device_status{device_id="${deviceId}"}[24h]) * 100`
  )
  
  return parseFloat(res.data.result[0].value[1])
}
```

---

## 5. 方案选择建议

### 5.1 推荐方案：混合方案

**理由**：
1. ✅ **性能最优**：设备列表查询直接从 PostgreSQL，无需查询时序库
2. ✅ **功能完整**：支持复杂筛选 + 历史分析 + 告警
3. ✅ **成本可控**：PostgreSQL 只存储当前状态，时序库存储历史
4. ✅ **架构清晰**：元数据和时序数据分离，职责明确

### 5.2 纯时序库方案的适用场景

**适合**：
- ✅ 设备数量少（< 100 台）
- ✅ 主要关注状态历史和趋势分析
- ✅ 不需要复杂的设备管理功能
- ✅ 已有完善的时序库基础设施

**不适合**：
- ❌ 设备数量多（> 1000 台）
- ❌ 需要复杂的设备筛选和关联查询
- ❌ 设备列表页面访问频繁
- ❌ 对查询性能要求高

### 5.3 实施建议

**阶段 1**：实现 PostgreSQL 存储（基础功能）
- 采集端上报时更新 PostgreSQL
- 前端从 PostgreSQL 查询设备状态
- 实现定时检查兜底机制

**阶段 2**：增加时序库存储（增强功能）
- 采集端生成 device_status 指标
- 中心端同时更新 PostgreSQL 和时序库
- 前端增加状态历史和趋势分析页面

**阶段 3**：优化和告警（高级功能）
- 配置 vmalert 告警规则
- 实现设备 SLA 统计
- 优化查询性能

---

## 6. 实现方案（混合方案）

### 4.1 采集端上报状态

#### 4.1.1 修改数据上报接口

**当前接口**: `POST /api/v1/data/ingest`

**当前请求格式**:
```json
{
  "metrics": [
    {
      "name": "ping_rtt_avg_ms",
      "value": 12.5,
      "labels": {
        "device_id": "dev-25422c94",
        "task_id": "task-177bfd59"
      },
      "timestamp": 1700500000000
    }
  ]
}
```

**新增字段**:
```json
{
  "metrics": [...],
  "device_status": {
    "dev-25422c94": {
      "status": "online",
      "last_seen": "2025-11-20T10:00:00Z"
    },
    "dev-xxx": {
      "status": "offline",
      "error": "connection timeout"
    }
  }
}
```

#### 4.1.2 采集端实现

**位置**: `orbital-sentinels/internal/sender/core_sender.go`

```go
// 修改 Send 方法，添加设备状态信息
func (cs *CoreSender) Send(metrics []*plugin.Metric) error {
    // 构造设备状态映射
    deviceStatus := make(map[string]interface{})
    
    // 从 metrics 中提取设备状态
    for _, m := range metrics {
        if deviceID, ok := m.Labels["device_id"]; ok {
            // 如果有指标数据，说明采集成功
            deviceStatus[deviceID] = map[string]interface{}{
                "status":    "online",
                "last_seen": time.Now().Format(time.RFC3339),
            }
        }
    }
    
    // 构造请求体
    payload := map[string]interface{}{
        "metrics":       metrics,
        "device_status": deviceStatus,
    }
    
    // ... 发送请求
}
```

**更好的方案**: 在调度器中记录任务执行状态

**位置**: `orbital-sentinels/internal/scheduler/scheduler.go`

```go
// 在 runTask 中记录设备状态
func (s *Scheduler) runTask(st *ScheduledTask) {
    // ... 执行采集
    metrics, err := p.Collect(taskCtx, st.Task)
    
    // 记录设备状态
    deviceStatus := DeviceStatus{
        DeviceID: st.Task.DeviceID,
        Status:   "online",
        LastSeen: time.Now(),
    }
    
    if err != nil {
        deviceStatus.Status = "offline"
        deviceStatus.Error = err.Error()
    }
    
    // 调用指标处理器（传递设备状态）
    if s.onMetrics != nil {
        s.onMetrics(metrics, st.Task, deviceStatus)
    }
}
```

#### 4.1.3 中心端实现

**位置**: `gravital-core/internal/api/handler/forwarder_handler.go`

```go
// IngestMetrics 接收指标数据
func (h *ForwarderHandler) IngestMetrics(c *gin.Context) {
    // ... 解压和解析数据
    
    var req struct {
        Metrics      []*forwarder.Metric       `json:"metrics"`
        DeviceStatus map[string]DeviceStatusInfo `json:"device_status"`
    }
    
    if err := json.NewDecoder(reader).Decode(&req); err != nil {
        ErrorResponse(c, http.StatusBadRequest, 40001, err.Error())
        return
    }
    
    // 更新设备状态
    if len(req.DeviceStatus) > 0 {
        h.updateDeviceStatus(c.Request.Context(), req.DeviceStatus)
    }
    
    // 转发指标数据
    if err := h.service.IngestMetrics(c.Request.Context(), req.Metrics); err != nil {
        // ...
    }
    
    SuccessResponse(c, gin.H{"received": len(req.Metrics)})
}

// updateDeviceStatus 更新设备状态
func (h *ForwarderHandler) updateDeviceStatus(ctx context.Context, statusMap map[string]DeviceStatusInfo) {
    for deviceID, info := range statusMap {
        now := time.Now()
        updates := map[string]interface{}{
            "status":     info.Status,
            "last_seen":  now,
            "updated_at": now,
        }
        
        if err := h.db.Model(&model.Device{}).
            Where("device_id = ?", deviceID).
            Updates(updates).Error; err != nil {
            h.logger.Error("Failed to update device status",
                zap.String("device_id", deviceID),
                zap.Error(err))
        }
    }
}
```

### 4.2 中心端定时检查（兜底机制）

#### 4.2.1 创建定时任务

**位置**: `gravital-core/internal/service/device_monitor.go`（新建文件）

```go
package service

import (
    "context"
    "time"
    
    "go.uber.org/zap"
    "gorm.io/gorm"
    
    "github.com/celestial/gravital-core/internal/model"
)

// DeviceMonitor 设备监控服务
type DeviceMonitor struct {
    db     *gorm.DB
    logger *zap.Logger
    ticker *time.Ticker
    done   chan struct{}
}

// NewDeviceMonitor 创建设备监控服务
func NewDeviceMonitor(db *gorm.DB, logger *zap.Logger) *DeviceMonitor {
    return &DeviceMonitor{
        db:     db,
        logger: logger,
        done:   make(chan struct{}),
    }
}

// Start 启动监控
func (m *DeviceMonitor) Start() {
    m.ticker = time.NewTicker(1 * time.Minute) // 每分钟检查一次
    
    go func() {
        for {
            select {
            case <-m.ticker.C:
                m.checkDeviceStatus()
            case <-m.done:
                return
            }
        }
    }()
    
    m.logger.Info("Device monitor started")
}

// Stop 停止监控
func (m *DeviceMonitor) Stop() {
    if m.ticker != nil {
        m.ticker.Stop()
    }
    close(m.done)
    m.logger.Info("Device monitor stopped")
}

// checkDeviceStatus 检查设备状态
func (m *DeviceMonitor) checkDeviceStatus() {
    ctx := context.Background()
    
    // 定义超时时间（5 分钟未上报视为离线）
    timeout := time.Now().Add(-5 * time.Minute)
    
    // 查找长时间未上报的在线设备
    result := m.db.WithContext(ctx).
        Model(&model.Device{}).
        Where("status = ?", "online").
        Where("last_seen < ? OR last_seen IS NULL", timeout).
        Updates(map[string]interface{}{
            "status":     "offline",
            "updated_at": time.Now(),
        })
    
    if result.Error != nil {
        m.logger.Error("Failed to update offline devices", zap.Error(result.Error))
        return
    }
    
    if result.RowsAffected > 0 {
        m.logger.Info("Marked devices as offline",
            zap.Int64("count", result.RowsAffected))
    }
}
```

#### 4.2.2 启动监控服务

**位置**: `gravital-core/cmd/server/main.go`

```go
func main() {
    // ... 初始化其他服务
    
    // 创建设备监控服务
    deviceMonitor := service.NewDeviceMonitor(db, logger)
    deviceMonitor.Start()
    
    // 优雅关闭
    go func() {
        <-ctx.Done()
        deviceMonitor.Stop()
    }()
    
    // ... 启动 HTTP 服务器
}
```

---

## 5. 前端展示

### 5.1 状态颜色映射

```typescript
// gravital-core/web/src/components/StatusBadge.vue
const statusColorMap = {
  online: 'success',   // 绿色
  offline: 'danger',   // 红色
  error: 'warning',    // 橙色
  unknown: 'info'      // 灰色
}

const statusTextMap = {
  online: '在线',
  offline: '离线',
  error: '错误',
  unknown: '未知'
}
```

### 5.2 设备列表显示

```vue
<template>
  <el-table :data="devices">
    <el-table-column label="状态" width="100">
      <template #default="{ row }">
        <StatusBadge :status="row.status" />
      </template>
    </el-table-column>
    
    <el-table-column label="最后上报" width="180">
      <template #default="{ row }">
        <span v-if="row.last_seen">
          {{ formatDateTime(row.last_seen) }}
        </span>
        <span v-else class="text-gray-400">从未上报</span>
      </template>
    </el-table-column>
  </el-table>
</template>
```

---

## 6. 数据流转完整流程

```
┌─────────────────────────────────────────────────────────────────┐
│ 1. 设备录入                                                      │
│    用户在前端创建设备                                             │
│    ├─> POST /api/v1/devices                                     │
│    └─> status = "unknown"                                       │
└────────────────────────┬────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────┐
│ 2. 创建采集任务                                                   │
│    用户配置采集任务                                               │
│    ├─> POST /api/v1/tasks                                       │
│    └─> 关联 device_id                                           │
└────────────────────────┬────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────┐
│ 3. 采集端拉取任务                                                 │
│    Sentinel 定时拉取任务列表                                      │
│    └─> GET /api/v1/sentinels/{id}/tasks                        │
└────────────────────────┬────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────┐
│ 4. 执行采集                                                      │
│    Scheduler 调度任务执行                                         │
│    ├─> Plugin.Collect()                                         │
│    ├─> 成功: metrics = [...]                                    │
│    └─> 失败: err = "connection timeout"                         │
└────────────────────────┬────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────┐
│ 5. 上报数据和状态                                                 │
│    Sender 发送数据到中心端                                        │
│    POST /api/v1/data/ingest                                     │
│    {                                                            │
│      "metrics": [...],                                          │
│      "device_status": {                                         │
│        "dev-25422c94": {                                        │
│          "status": "online",                                    │
│          "last_seen": "2025-11-20T10:00:00Z"                   │
│        }                                                        │
│      }                                                          │
│    }                                                            │
└────────────────────────┬────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────┐
│ 6. 中心端更新设备状态                                             │
│    ForwarderHandler.updateDeviceStatus()                        │
│    UPDATE devices                                               │
│    SET status = 'online',                                       │
│        last_seen = NOW()                                        │
│    WHERE device_id = 'dev-25422c94'                            │
└────────────────────────┬────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────┐
│ 7. 定时检查（兜底）                                               │
│    DeviceMonitor 每分钟检查一次                                   │
│    UPDATE devices                                               │
│    SET status = 'offline'                                       │
│    WHERE status = 'online'                                      │
│      AND (last_seen < NOW() - 5分钟 OR last_seen IS NULL)      │
└────────────────────────┬────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────┐
│ 8. 前端展示                                                      │
│    设备列表页面                                                   │
│    ├─> 查询: GET /api/v1/devices                                │
│    └─> 显示: 状态徽章 + 最后上报时间                              │
└─────────────────────────────────────────────────────────────────┘
```

---

## 7. 实现优先级

### 阶段 1：基础功能（必须）
- [ ] 采集端上报时携带设备状态
- [ ] 中心端接收并更新设备状态
- [ ] 前端显示设备状态

### 阶段 2：兜底机制（推荐）
- [ ] 实现 DeviceMonitor 定时检查
- [ ] 配置超时时间（可配置化）
- [ ] 添加状态变更日志

### 阶段 3：增强功能（可选）
- [ ] 设备状态变更事件通知
- [ ] 设备状态历史记录
- [ ] 设备状态变更告警
- [ ] 设备可用性统计（SLA）

---

## 8. 配置示例

```yaml
# gravital-core/config/config.yaml
device_monitor:
  enabled: true
  check_interval: 60s        # 检查间隔
  offline_timeout: 300s      # 5 分钟未上报视为离线
  cleanup_interval: 24h      # 清理历史记录间隔
```

---

## 9. 总结

### 当前状态
- ✅ 设备录入时状态初始化为 `unknown`
- ❌ **没有实现**状态自动更新机制
- ❌ `last_seen` 字段未被使用

### 推荐方案
- **混合方案**: 采集端实时上报 + 中心端定时检查
- **优先级**: 先实现采集端上报（阶段 1），再实现定时检查（阶段 2）

### 关键设计点
1. **实时性**: 采集成功/失败立即反映状态
2. **可靠性**: 定时检查作为兜底，防止状态不准确
3. **扩展性**: 预留状态变更事件，方便后续告警集成


