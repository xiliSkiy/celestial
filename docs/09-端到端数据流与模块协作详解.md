# 端到端数据流与模块协作详解

> **文档目标**：从业务场景出发，详细说明系统各模块如何协作，数据如何流转，各组件的职责边界和交互方式。

## 目录

- [1. 文档概述](#1-文档概述)
- [2. 系统全局视图](#2-系统全局视图)
- [3. 核心业务流程详解](#3-核心业务流程详解)
  - [3.1 设备接入与管理流程](#31-设备接入与管理流程)
  - [3.2 采集任务配置与下发流程](#32-采集任务配置与下发流程)
  - [3.3 数据采集与上报流程](#33-数据采集与上报流程)
  - [3.4 数据转发与存储流程](#34-数据转发与存储流程)
  - [3.5 数据查询与展示流程](#35-数据查询与展示流程)
  - [3.6 告警触发与处理流程](#36-告警触发与处理流程)
- [4. 模块职责与边界](#4-模块职责与边界)
- [5. 数据库设计与数据流](#5-数据库设计与数据流)
- [6. 时序数据库使用详解](#6-时序数据库使用详解)
- [7. 前端数据消费场景](#7-前端数据消费场景)
- [8. 关键技术决策说明](#8-关键技术决策说明)

---

## 1. 文档概述

### 1.1 为什么需要这份文档

现有设计文档主要描述了"系统有哪些模块"和"每个模块做什么"，但对于以下问题缺乏清晰说明：

- **数据流转路径**：数据从采集到展示，经过了哪些环节？每个环节做了什么处理？
- **模块协作方式**：各模块之间通过什么方式通信？数据格式是什么？
- **职责边界**：某个功能应该由哪个模块负责？边界在哪里？
- **存储策略**：什么数据存 PostgreSQL？什么数据存时序库？为什么？
- **前端消费**：前端从哪里获取数据？时序库的数据如何被前端使用？

### 1.2 文档组织方式

本文档采用**场景驱动**的方式，以典型业务流程为主线，详细说明：

1. **业务场景**：用户要完成什么任务
2. **涉及模块**：哪些模块参与
3. **交互序列**：模块间的调用顺序和数据流向
4. **数据变化**：每个环节数据的存储和转换
5. **关键决策**：为什么这样设计

---

## 2. 系统全局视图

### 2.1 系统架构分层

```
┌─────────────────────────────────────────────────────────────────┐
│                         用户层 (Browser)                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │  设备管理UI  │  │  任务配置UI  │  │  监控大盘UI  │  ...     │
│  └──────────────┘  └──────────────┘  └──────────────┘          │
└─────────────────────────────────────────────────────────────────┘
                              ▲
                              │ HTTP/WebSocket
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    中心端 (Gravital Core)                         │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  API Gateway (Gin Router + Middleware)                   │  │
│  └──────────────────────────────────────────────────────────┘  │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐         │
│  │ 设备服务 │ │ 任务服务 │ │ 告警服务 │ │ 用户服务 │  ...    │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘         │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  数据接收服务 (Ingest API)                                │  │
│  └──────────────────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  转发管理器 (Forwarder Manager)                           │  │
│  │  ┌────────────┐ ┌────────────┐ ┌────────────┐           │  │
│  │  │Prometheus  │ │VictoriaM   │ │ClickHouse  │           │  │
│  │  └────────────┘ └────────────┘ └────────────┘           │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
         │                              │                    ▲
         │ PostgreSQL                   │ Redis              │
         ▼                              ▼                    │
   ┌──────────┐                   ┌──────────┐              │
   │ 元数据库 │                   │  缓存层  │              │
   │(配置/状态)│                   │(会话/锁) │              │
   └──────────┘                   └──────────┘              │
                                                             │
                              HTTP (数据上报)                │
                                                             │
┌─────────────────────────────────────────────────────────────────┐
│                   采集端 (Orbital Sentinels)                      │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  Agent Controller                                         │  │
│  │  ┌────────────┐ ┌────────────┐ ┌────────────┐          │  │
│  │  │ 注册模块   │ │ 心跳模块   │ │ 任务拉取   │          │  │
│  │  └────────────┘ └────────────┘ └────────────┘          │  │
│  └──────────────────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  Scheduler (任务调度器)                                   │  │
│  └──────────────────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  Plugin Manager                                           │  │
│  │  ┌────────────┐ ┌────────────┐ ┌────────────┐          │  │
│  │  │ Ping 插件  │ │ SNMP 插件  │ │ SSH 插件   │  ...     │  │
│  │  └────────────┘ └────────────┘ └────────────┘          │  │
│  └──────────────────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  Sender (数据发送器)                                      │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              │ 直连/通过 Core
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    时序数据库 (TSDB)                              │
│  ┌────────────────┐  ┌────────────────┐  ┌────────────────┐   │
│  │ VictoriaMetrics│  │  Prometheus    │  │  ClickHouse    │   │
│  │  (推荐)        │  │                │  │  (大规模)      │   │
│  └────────────────┘  └────────────────┘  └────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              ▲
                              │ PromQL/SQL 查询
                              │
                        ┌─────────────┐
                        │  Grafana    │
                        │  (可选)     │
                        └─────────────┘
```

### 2.2 数据分类与存储策略

系统中的数据按用途和特性分为三类：

#### 2.2.1 元数据 (Metadata) → PostgreSQL

**特点**：变化频率低、需要事务支持、需要复杂查询

| 数据类型 | 表名 | 用途 | 更新频率 |
|---------|------|------|---------|
| 设备信息 | `devices` | 设备基本信息、连接配置 | 低 (手动配置) |
| 采集任务 | `collection_tasks` | 任务配置、调度参数 | 低 (手动配置) |
| 采集端信息 | `sentinels` | 采集端注册信息、状态 | 中 (心跳更新) |
| 告警规则 | `alert_rules` | 告警条件、阈值配置 | 低 (手动配置) |
| 告警事件 | `alert_events` | 告警历史记录 | 中 (告警触发) |
| 用户信息 | `users` | 用户账号、权限 | 低 (手动管理) |
| 转发器配置 | `forwarder_configs` | 转发目标配置 | 低 (手动配置) |

**为什么用 PostgreSQL？**
- 需要 JOIN 查询（如：查询设备关联的任务）
- 需要事务保证（如：创建任务时关联设备）
- 数据量不大（配置类数据通常在万级以下）
- 需要复杂过滤和排序

#### 2.2.2 时序数据 (Time Series) → TSDB

**特点**：高频写入、按时间查询、数据量大

| 数据类型 | 存储位置 | 用途 | 写入频率 |
|---------|---------|------|---------|
| 采集指标 | VictoriaMetrics/Prometheus | CPU、内存、网络等监控指标 | 高 (秒级) |
| 性能数据 | VictoriaMetrics | 设备性能趋势 | 高 (秒级) |
| 巡检结果 | VictoriaMetrics | Ping 延迟、丢包率等 | 中 (分钟级) |

**为什么用时序数据库？**
- 针对时间序列优化，压缩率高（10:1 以上）
- 查询性能好（按时间范围查询）
- 支持降采样（自动聚合历史数据）
- 支持 PromQL（强大的时序查询语言）

#### 2.2.3 缓存数据 (Cache) → Redis

**特点**：临时数据、高频访问、可丢失

| 数据类型 | Key 格式 | 用途 | 过期时间 |
|---------|---------|------|---------|
| 用户会话 | `session:{token}` | 登录状态 | 24h |
| 采集端在线状态 | `sentinel:online:{id}` | 快速判断在线 | 3min (心跳刷新) |
| 分布式锁 | `lock:{resource}` | 防止并发冲突 | 30s |
| 限流计数 | `ratelimit:{ip}` | API 限流 | 1min |

---

## 3. 核心业务流程详解

### 3.1 设备接入与管理流程

#### 3.1.1 业务场景

运维人员需要将一台新服务器纳入监控系统，配置其连接信息，以便后续采集数据。

#### 3.1.2 流程图

```
┌─────────┐      ┌─────────┐      ┌─────────┐      ┌─────────┐
│  前端   │      │ API网关 │      │设备服务 │      │PostgreSQL│
└────┬────┘      └────┬────┘      └────┬────┘      └────┬────┘
     │                │                │                │
     │ 1. POST /devices               │                │
     │ {name, type,   │                │                │
     │  connection_config}             │                │
     ├───────────────>│                │                │
     │                │                │                │
     │                │ 2. 认证/鉴权   │                │
     │                │ (JWT Middleware)                │
     │                ├────────┐       │                │
     │                │        │       │                │
     │                │<───────┘       │                │
     │                │                │                │
     │                │ 3. CreateDevice()               │
     │                ├───────────────>│                │
     │                │                │                │
     │                │                │ 4. 生成 device_id
     │                │                │    (UUID)      │
     │                │                ├────────┐       │
     │                │                │        │       │
     │                │                │<───────┘       │
     │                │                │                │
     │                │                │ 5. INSERT INTO devices
     │                │                ├───────────────>│
     │                │                │                │
     │                │                │ 6. 返回设备ID  │
     │                │                │<───────────────┤
     │                │                │                │
     │                │ 7. 返回设备信息 │                │
     │                │<───────────────┤                │
     │                │                │                │
     │ 8. 200 OK      │                │                │
     │ {device_id,    │                │                │
     │  name, ...}    │                │                │
     │<───────────────┤                │                │
     │                │                │                │
```

#### 3.1.3 详细步骤说明

**步骤 1：前端发起请求**

```http
POST /api/v1/devices
Authorization: Bearer <jwt_token>
Content-Type: application/json

{
  "name": "生产服务器-01",
  "device_type": "server",
  "group_id": null,
  "connection_config": {
    "protocol": "ssh",
    "host": "192.168.1.100",
    "port": 22,
    "username": "admin",
    "password": "encrypted_password"
  },
  "labels": {
    "env": "production",
    "region": "beijing"
  }
}
```

**步骤 2：API 网关处理**

```go
// 中间件链
router.POST("/devices", 
    middleware.Auth(),           // 验证 JWT token
    middleware.Permission("device:create"), // 检查权限
    deviceHandler.Create)        // 业务处理
```

**步骤 3-4：设备服务处理**

```go
// internal/service/device_service.go
func (s *deviceService) CreateDevice(ctx context.Context, req *CreateDeviceRequest) (*model.Device, error) {
    // 生成唯一设备 ID
    deviceID := fmt.Sprintf("dev-%s", generateShortID())
    
    device := &model.Device{
        DeviceID:         deviceID,
        Name:             req.Name,
        DeviceType:       req.DeviceType,
        GroupID:          req.GroupID,
        ConnectionConfig: req.ConnectionConfig,
        Labels:           req.Labels,
        Status:           "unknown",  // 初始状态
        CreatedAt:        time.Now(),
        UpdatedAt:        time.Now(),
    }
    
    // 保存到数据库
    return s.repo.Create(ctx, device)
}
```

**步骤 5：数据库存储**

```sql
INSERT INTO devices (
    device_id, name, device_type, group_id, 
    connection_config, labels, status, 
    created_at, updated_at
) VALUES (
    'dev-25422c94', 
    '生产服务器-01', 
    'server', 
    NULL,
    '{"protocol":"ssh","host":"192.168.1.100",...}'::jsonb,
    '{"env":"production","region":"beijing"}'::jsonb,
    'unknown',
    NOW(),
    NOW()
);
```

**步骤 6-8：返回结果**

```json
{
  "code": 0,
  "data": {
    "id": 1,
    "device_id": "dev-25422c94",
    "name": "生产服务器-01",
    "device_type": "server",
    "status": "unknown",
    "connection_config": {
      "protocol": "ssh",
      "host": "192.168.1.100",
      "port": 22,
      "username": "admin"
      // password 不返回
    },
    "created_at": "2025-11-20T10:00:00Z"
  }
}
```

#### 3.1.4 关键设计决策

**Q1: 为什么需要 device_id 和数据库主键 id？**

- `id`: 数据库自增主键，内部使用，不暴露给外部
- `device_id`: 业务唯一标识，全局唯一，用于 API 和跨系统引用
- **好处**：
  - 数据库主键可以优化查询性能（整型索引）
  - device_id 可以跨系统迁移，不依赖数据库
  - 安全性更好（不暴露数据库内部 ID）

**Q2: connection_config 为什么用 JSONB？**

- 不同设备类型的连接配置差异大（SSH vs SNMP vs HTTP）
- JSONB 支持灵活的 schema
- PostgreSQL 的 JSONB 支持索引和查询
- 避免为每种设备类型创建不同的表

**Q3: 密码如何存储？**

```go
// 存储前加密
encrypted := encrypt(password, secretKey)
device.ConnectionConfig["password"] = encrypted

// 使用时解密
password := decrypt(device.ConnectionConfig["password"], secretKey)
```

---

### 3.2 采集任务配置与下发流程

#### 3.2.1 业务场景

运维人员为已接入的设备配置采集任务，指定采集内容（如 Ping 巡检）、采集频率、执行的采集端。

#### 3.2.2 流程图

```
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│  前端   │  │ API网关 │  │任务服务 │  │PostgreSQL│  │ 采集端  │
└────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘
     │            │            │            │            │
     │ 1. POST /tasks         │            │            │
     │ {device_id, plugin,    │            │            │
     │  sentinel_id, config}  │            │            │
     ├───────────>│            │            │            │
     │            │            │            │            │
     │            │ 2. CreateTask()         │            │
     │            ├───────────>│            │            │
     │            │            │            │            │
     │            │            │ 3. 验证设备存在         │
     │            │            │ 验证采集端在线          │
     │            │            ├────────┐   │            │
     │            │            │        │   │            │
     │            │            │<───────┘   │            │
     │            │            │            │            │
     │            │            │ 4. 生成 task_id        │
     │            │            │    计算下次执行时间     │
     │            │            ├────────┐   │            │
     │            │            │        │   │            │
     │            │            │<───────┘   │            │
     │            │            │            │            │
     │            │            │ 5. INSERT INTO tasks   │
     │            │            ├───────────>│            │
     │            │            │            │            │
     │            │            │ 6. 返回任务ID          │
     │            │            │<───────────┤            │
     │            │            │            │            │
     │            │ 7. 返回任务信息         │            │
     │            │<───────────┤            │            │
     │            │            │            │            │
     │ 8. 200 OK  │            │            │            │
     │<───────────┤            │            │            │
     │            │            │            │            │
     │            │            │            │  9. 定时拉取任务
     │            │            │            │  GET /sentinel-tasks
     │            │            │            │<───────────┤
     │            │            │            │            │
     │            │ 10. GetSentinelTasks() │            │
     │            ├───────────>│            │            │
     │            │            │            │            │
     │            │            │ 11. SELECT tasks       │
     │            │            │     WHERE sentinel_id  │
     │            │            │     AND enabled=true   │
     │            │            ├───────────>│            │
     │            │            │            │            │
     │            │            │ 12. 合并设备连接配置    │
     │            │            │<───────────┤            │
     │            │            │            │            │
     │            │ 13. 返回任务列表        │            │
     │            │<───────────┤            │            │
     │            │            │            │            │
     │            │ 14. 200 OK │            │            │
     │            │ [tasks]    │            │            │
     │            ├───────────────────────────────────>│
     │            │            │            │            │
     │            │            │            │ 15. 更新本地任务
     │            │            │            │     加入调度器
     │            │            │            │<────────┐  │
     │            │            │            │         │  │
     │            │            │            │<────────┘  │
```

#### 3.2.3 详细步骤说明

**步骤 1：前端创建任务**

```http
POST /api/v1/tasks
Content-Type: application/json

{
  "device_id": "dev-25422c94",
  "sentinel_id": "sentinel-beijing-1-xxx",
  "plugin_name": "ping",
  "interval_seconds": 60,
  "timeout_seconds": 30,
  "enabled": true,
  "priority": 5,
  "retry_count": 3,
  "config": {
    "count": 4,
    "timeout": "5s"
  }
}
```

**步骤 3-5：任务服务处理**

```go
// internal/service/task_service.go
func (s *taskService) CreateTask(ctx context.Context, req *CreateTaskRequest) (*model.CollectionTask, error) {
    // 1. 验证设备存在
    device, err := s.deviceRepo.GetByDeviceID(ctx, req.DeviceID)
    if err != nil {
        return nil, fmt.Errorf("device not found: %w", err)
    }
    
    // 2. 验证采集端在线（可选）
    sentinel, err := s.sentinelRepo.GetBySentinelID(ctx, req.SentinelID)
    if err != nil {
        return nil, fmt.Errorf("sentinel not found: %w", err)
    }
    
    // 3. 生成任务 ID
    taskID := fmt.Sprintf("task-%s", generateShortID())
    
    // 4. 计算下次执行时间
    nextExecution := time.Now().Add(time.Duration(req.IntervalSeconds) * time.Second)
    
    task := &model.CollectionTask{
        TaskID:          taskID,
        DeviceID:        req.DeviceID,
        SentinelID:      req.SentinelID,
        PluginName:      req.PluginName,
        Config:          req.Config,
        IntervalSeconds: req.IntervalSeconds,
        TimeoutSeconds:  req.TimeoutSeconds,
        Enabled:         req.Enabled,
        Priority:        req.Priority,
        RetryCount:      req.RetryCount,
        NextExecutionAt: &nextExecution,
        CreatedAt:       time.Now(),
        UpdatedAt:       time.Now(),
    }
    
    // 5. 保存到数据库
    return s.taskRepo.Create(ctx, task)
}
```

**步骤 9-12：采集端拉取任务**

采集端每 60 秒拉取一次任务列表：

```go
// orbital-sentinels/internal/client/task_client.go
func (c *TaskClient) GetTasks(ctx context.Context) ([]*TaskWithInterval, error) {
    req, _ := http.NewRequestWithContext(ctx, "GET", 
        c.baseURL+"/api/v1/sentinel-tasks", nil)
    
    // 设置认证头
    req.Header.Set("X-Sentinel-ID", c.sentinelID)
    req.Header.Set("X-API-Token", c.apiToken)
    
    resp, err := c.client.Do(req)
    // ... 处理响应
}
```

中心端返回任务时，会合并设备的连接配置：

```go
// gravital-core/internal/service/task_service.go
func (s *taskService) GetSentinelTasks(ctx context.Context, sentinelID string) ([]*model.CollectionTask, error) {
    // 1. 查询该采集端的所有启用任务
    tasks, err := s.taskRepo.GetBySentinelID(ctx, sentinelID)
    
    // 2. 为每个任务加载设备信息并合并配置
    for _, task := range tasks {
        device, err := s.deviceRepo.GetByDeviceID(ctx, task.DeviceID)
        if err != nil {
            continue
        }
        
        // 合并设备连接配置到任务配置中
        if task.Config == nil {
            task.Config = make(model.JSONB)
        }
        for k, v := range device.ConnectionConfig {
            if _, exists := task.Config[k]; !exists {
                task.Config[k] = v  // 任务配置优先
            }
        }
        
        task.Device = device
    }
    
    return tasks, nil
}
```

**步骤 15：采集端更新调度器**

```go
// orbital-sentinels/internal/scheduler/scheduler.go
func (s *Scheduler) UpdateTasksWithIntervals(tasksWithIntervals []*client.TaskWithInterval) {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    newTaskMap := make(map[string]*client.TaskWithInterval)
    for _, twi := range tasksWithIntervals {
        newTaskMap[twi.Task.TaskID] = twi
    }
    
    // 添加新任务
    for taskID, twi := range newTaskMap {
        if _, exists := s.tasks[taskID]; !exists {
            st := &ScheduledTask{
                Task:     twi.Task,
                Interval: twi.Interval,
                NextRun:  time.Now(),
            }
            s.tasks[taskID] = st
            s.taskQueue.Push(st)
            logger.Info("Added new task", 
                zap.String("task_id", taskID),
                zap.Duration("interval", twi.Interval))
        }
    }
    
    // 移除已删除的任务
    for taskID := range s.tasks {
        if _, exists := newTaskMap[taskID]; !exists {
            delete(s.tasks, taskID)
            logger.Info("Removed task", zap.String("task_id", taskID))
        }
    }
}
```

#### 3.2.4 关键设计决策

**Q1: 为什么采集端要定时拉取任务，而不是中心端推送？**

- **拉取模式优势**：
  - 采集端可能在 NAT 后面，中心端无法主动连接
  - 采集端重启后可以自动恢复任务
  - 避免维护长连接的复杂性
  - 采集端可以自主控制拉取频率

- **推送模式问题**：
  - 需要 WebSocket 或长轮询
  - 连接管理复杂（断线重连、心跳）
  - 扩展性差（大量采集端时连接数爆炸）

**Q2: 为什么要合并设备连接配置到任务配置？**

```go
// 任务配置
{
  "count": 4,
  "timeout": "5s"
}

// 设备连接配置
{
  "protocol": "ssh",
  "host": "192.168.1.100",
  "port": 22,
  "username": "admin",
  "password": "encrypted"
}

// 合并后（采集端收到）
{
  "count": 4,
  "timeout": "5s",
  "protocol": "ssh",
  "host": "192.168.1.100",
  "port": 22,
  "username": "admin",
  "password": "encrypted"
}
```

**好处**：
- 插件只需要从 `task.Config` 获取所有参数
- 避免插件直接访问设备信息（解耦）
- 任务配置可以覆盖设备配置（灵活性）

**Q3: next_execution_at 字段的作用？**

- 用于中心端查询"即将执行的任务"
- 用于任务执行历史追踪
- 用于手动触发任务（立即执行）

```go
// 手动触发任务
func (s *taskService) Trigger(ctx context.Context, id uint) error {
    task, _ := s.taskRepo.GetByID(ctx, id)
    
    // 设置为立即执行
    now := time.Now()
    task.NextExecutionAt = &now
    
    return s.taskRepo.Update(ctx, task)
}
```

---



### 3.3 数据采集与上报流程

#### 3.3.1 业务场景

采集端按照任务配置，定时执行插件采集数据，并将采集结果上报到中心端。

#### 3.3.2 流程图

```
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│调度器   │  │插件管理器│  │ Ping插件│  │ Sender  │  │中心端   │
└────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘
     │            │            │            │            │
     │ 1. 时间到，执行任务     │            │            │
     │ task: {device_id,      │            │            │
     │        plugin: "ping", │            │            │
     │        config: {...}}  │            │            │
     ├────────┐   │            │            │            │
     │        │   │            │            │            │
     │<───────┘   │            │            │            │
     │            │            │            │            │
     │ 2. GetPlugin("ping")   │            │            │
     ├───────────>│            │            │            │
     │            │            │            │            │
     │ 3. 返回插件实例         │            │            │
     │<───────────┤            │            │            │
     │            │            │            │            │
     │ 4. plugin.Collect(task)│            │            │
     ├────────────────────────>│            │            │
     │            │            │            │            │
     │            │            │ 5. 解析配置            │
     │            │            │    host = task.Config["host"]
     │            │            │    count = task.Config["count"]
     │            │            ├────────┐   │            │
     │            │            │        │   │            │
     │            │            │<───────┘   │            │
     │            │            │            │            │
     │            │            │ 6. 执行 ping 命令      │
     │            │            │    ping -c 4 192.168.1.100
     │            │            ├────────┐   │            │
     │            │            │        │   │            │
     │            │            │<───────┘   │            │
     │            │            │            │            │
     │            │            │ 7. 解析结果            │
     │            │            │    avg_rtt = 12.5ms    │
     │            │            │    packet_loss = 0%    │
     │            │            ├────────┐   │            │
     │            │            │        │   │            │
     │            │            │<───────┘   │            │
     │            │            │            │            │
     │ 8. 返回指标数据         │            │            │
     │ [{name: "ping_rtt",    │            │            │
     │   value: 12.5,         │            │            │
     │   labels: {...}}, ...] │            │            │
     │<────────────────────────┤            │            │
     │            │            │            │            │
     │ 9. onMetrics(metrics, task)         │            │
     ├────────────────────────────────────>│            │
     │            │            │            │            │
     │            │            │  10. 缓存到内存 Buffer │
     │            │            │      (批量发送)        │
     │            │            │            ├────────┐  │
     │            │            │            │        │  │
     │            │            │            │<───────┘  │
     │            │            │            │            │
     │            │            │  11. Buffer 满或超时   │
     │            │            │      触发发送          │
     │            │            │            ├────────┐  │
     │            │            │            │        │  │
     │            │            │            │<───────┘  │
     │            │            │            │            │
     │            │            │  12. POST /data/ingest │
     │            │            │      (gzip 压缩)       │
     │            │            │            ├───────────>│
     │            │            │            │            │
     │            │            │            │  13. 解压数据
     │            │            │            │      解析JSON
     │            │            │            │<────────┐  │
     │            │            │            │         │  │
     │            │            │            │<────────┘  │
     │            │            │            │            │
     │            │            │            │  14. 转发到
     │            │            │            │      Forwarder
     │            │            │            │      Manager
     │            │            │            │<────────┐  │
     │            │            │            │         │  │
     │            │            │            │<────────┘  │
     │            │            │            │            │
     │            │            │  15. 200 OK            │
     │            │            │            │<───────────┤
```

#### 3.3.3 关键设计决策

**Q1: 设备状态（status）如何更新？**

**当前实现**：
- 设备录入时，状态初始化为 `"unknown"`
- ⚠️ **问题**：目前系统**没有实现**设备状态的自动更新机制

**推荐方案**（混合方案）：

1. **采集端实时上报**（实时性）
   ```go
   // 采集成功/失败时，上报设备状态
   POST /api/v1/data/ingest
   {
     "metrics": [...],
     "device_status": {
       "dev-25422c94": {
         "status": "online",
         "last_seen": "2025-11-20T10:00:00Z"
       }
     }
   }
   ```

2. **中心端定时检查**（可靠性兜底）
   ```go
   // 每分钟检查一次，5分钟未上报视为离线
   UPDATE devices 
   SET status = 'offline'
   WHERE status = 'online' 
     AND last_seen < NOW() - INTERVAL '5 minutes'
   ```

**状态流转**：
```
unknown (初始) → online (采集成功) → offline (超时未上报) → online (恢复)
                                  ↘ error (配置错误)
```

**详细设计**: 参见 [10-设备状态管理机制.md](./10-设备状态管理机制.md)

---

由于内容较长，我将分多个文件创建。让我创建第二部分文件：

