# 插件开发指南

## 1. 概述

Orbital Sentinel 采用插件化架构，允许开发者轻松扩展各种数据采集能力。本指南将帮助您快速开发自己的采集插件。

## 2. 插件类型

### 2.1 按协议分类
- **网络协议**: SNMP, Modbus, OPC-UA, MQTT, BACnet
- **应用协议**: HTTP/HTTPS, WebSocket, gRPC
- **数据库**: MySQL, PostgreSQL, MongoDB, Redis
- **系统**: SSH, WMI, PowerShell, Shell Script
- **云服务**: AWS CloudWatch, Azure Monitor, Prometheus

### 2.2 按功能分类
- **指标采集**: CPU, 内存, 磁盘, 网络
- **日志采集**: Syslog, 应用日志
- **事件采集**: 系统事件, 告警事件
- **拓扑发现**: 网络拓扑, 设备关系

## 3. 快速开始

### 3.1 环境准备
```bash
# 安装 Go 1.21+
go version

# 克隆项目
git clone https://github.com/celestial/orbital-sentinels.git
cd orbital-sentinels

# 安装依赖
go mod download
```

### 3.2 创建插件项目
```bash
# 使用脚手架工具
./scripts/create-plugin.sh my-plugin

# 生成的目录结构
plugins/my-plugin/
├── plugin.yaml          # 插件配置
├── my_plugin.go         # 插件实现
├── my_plugin_test.go    # 单元测试
├── README.md            # 说明文档
└── go.mod               # 依赖管理
```

## 4. 插件开发

### 4.1 插件接口实现

```go
// plugins/my-plugin/my_plugin.go
package main

import (
    "context"
    "fmt"
    "time"
    
    "github.com/celestial/orbital-sentinels/sdk"
)

// MyPlugin 实现 Plugin 接口
type MyPlugin struct {
    sdk.BasePlugin           // 继承基础实现
    config     *MyConfig
    // 其他字段...
}

// MyConfig 插件配置
type MyConfig struct {
    Timeout  time.Duration `yaml:"timeout"`
    Retries  int           `yaml:"retries"`
    // 其他配置字段...
}

// Meta 返回插件元信息
func (p *MyPlugin) Meta() sdk.PluginMeta {
    return sdk.PluginMeta{
        Name:        "my-plugin",
        Version:     "1.0.0",
        Description: "My awesome plugin",
        Author:      "Your Name",
        DeviceTypes: []string{"my-device-type"},
    }
}

// Schema 返回配置 Schema
func (p *MyPlugin) Schema() sdk.PluginSchema {
    return sdk.PluginSchema{
        Meta: p.Meta(),
        DeviceFields: []sdk.DeviceField{
            {
                Name:        "host",
                Type:        "string",
                Required:    true,
                Description: "设备地址",
            },
            {
                Name:        "port",
                Type:        "int",
                Required:    false,
                Default:     8080,
                Description: "端口号",
            },
            {
                Name:        "username",
                Type:        "string",
                Required:    true,
                Description: "用户名",
            },
            {
                Name:        "password",
                Type:        "password",
                Required:    true,
                Description: "密码",
            },
        },
        ConfigFields: []sdk.DeviceField{
            {
                Name:        "timeout",
                Type:        "int",
                Required:    false,
                Default:     30,
                Description: "超时时间（秒）",
            },
            {
                Name:        "retries",
                Type:        "int",
                Required:    false,
                Default:     3,
                Description: "重试次数",
            },
        },
    }
}

// Init 初始化插件
func (p *MyPlugin) Init(config map[string]interface{}) error {
    // 解析配置
    p.config = &MyConfig{}
    if timeout, ok := config["timeout"].(int); ok {
        p.config.Timeout = time.Duration(timeout) * time.Second
    } else {
        p.config.Timeout = 30 * time.Second
    }
    
    if retries, ok := config["retries"].(int); ok {
        p.config.Retries = retries
    } else {
        p.config.Retries = 3
    }
    
    // 初始化资源（连接池等）
    // ...
    
    return nil
}

// ValidateConfig 验证设备配置
func (p *MyPlugin) ValidateConfig(deviceConfig map[string]interface{}) error {
    // 验证必填字段
    if _, ok := deviceConfig["host"]; !ok {
        return fmt.Errorf("host is required")
    }
    
    if _, ok := deviceConfig["username"]; !ok {
        return fmt.Errorf("username is required")
    }
    
    if _, ok := deviceConfig["password"]; !ok {
        return fmt.Errorf("password is required")
    }
    
    return nil
}

// TestConnection 测试连接
func (p *MyPlugin) TestConnection(deviceConfig map[string]interface{}) error {
    // 尝试连接设备
    host := deviceConfig["host"].(string)
    port := deviceConfig["port"].(int)
    
    // 示例：HTTP 健康检查
    url := fmt.Sprintf("http://%s:%d/health", host, port)
    ctx, cancel := context.WithTimeout(context.Background(), p.config.Timeout)
    defer cancel()
    
    // 发送请求...
    // 如果成功返回 nil，否则返回错误
    
    return nil
}

// Collect 采集数据
func (p *MyPlugin) Collect(ctx context.Context, task *sdk.CollectionTask) ([]*sdk.Metric, error) {
    // 解析设备配置
    host := task.DeviceConfig["host"].(string)
    port := task.DeviceConfig["port"].(int)
    username := task.DeviceConfig["username"].(string)
    password := task.DeviceConfig["password"].(string)
    
    // 创建带超时的上下文
    ctx, cancel := context.WithTimeout(ctx, p.config.Timeout)
    defer cancel()
    
    // 连接设备并采集数据
    metrics := make([]*sdk.Metric, 0)
    
    // 示例：采集 CPU 使用率
    cpuUsage, err := p.collectCPUUsage(ctx, host, port, username, password)
    if err != nil {
        return nil, fmt.Errorf("failed to collect CPU: %w", err)
    }
    
    metrics = append(metrics, &sdk.Metric{
        Name:      "cpu_usage",
        Value:     cpuUsage,
        Timestamp: time.Now().Unix(),
        Labels: map[string]string{
            "device_id": task.DeviceID,
            "host":      host,
        },
        Type: sdk.MetricTypeGauge,
    })
    
    // 示例：采集内存使用率
    memUsage, err := p.collectMemoryUsage(ctx, host, port, username, password)
    if err != nil {
        // 部分失败可以继续，记录日志即可
        p.Log().Warnf("Failed to collect memory: %v", err)
    } else {
        metrics = append(metrics, &sdk.Metric{
            Name:      "memory_usage",
            Value:     memUsage,
            Timestamp: time.Now().Unix(),
            Labels: map[string]string{
                "device_id": task.DeviceID,
                "host":      host,
            },
            Type: sdk.MetricTypeGauge,
        })
    }
    
    return metrics, nil
}

// Close 关闭插件
func (p *MyPlugin) Close() error {
    // 清理资源（关闭连接、释放资源等）
    return nil
}

// 辅助方法
func (p *MyPlugin) collectCPUUsage(ctx context.Context, host string, port int, username, password string) (float64, error) {
    // 实现具体的采集逻辑
    // ...
    return 75.5, nil
}

func (p *MyPlugin) collectMemoryUsage(ctx context.Context, host string, port int, username, password string) (float64, error) {
    // 实现具体的采集逻辑
    // ...
    return 60.2, nil
}

// NewPlugin 插件工厂函数（必须导出）
func NewPlugin() sdk.Plugin {
    return &MyPlugin{}
}
```

### 4.2 插件配置文件

```yaml
# plugins/my-plugin/plugin.yaml
meta:
  name: "my-plugin"
  version: "1.0.0"
  description: "My awesome monitoring plugin"
  author: "Your Name <your.email@example.com>"
  license: "Apache-2.0"
  homepage: "https://github.com/your/my-plugin"
  device_types:
    - my-device-type
    - another-type

# 设备连接字段定义
device_fields:
  - name: host
    type: string
    required: true
    description: "设备 IP 地址或主机名"
    placeholder: "192.168.1.100"
    validation: "^[a-zA-Z0-9.-]+$"
    
  - name: port
    type: int
    required: false
    default: 8080
    description: "端口号"
    validation: "^[0-9]{1,5}$"
    min: 1
    max: 65535
    
  - name: username
    type: string
    required: true
    description: "用户名"
    
  - name: password
    type: password
    required: true
    description: "密码"
    
  - name: use_ssl
    type: bool
    required: false
    default: false
    description: "是否使用 SSL/TLS"

# 插件级配置
config_fields:
  - name: timeout
    type: int
    required: false
    default: 30
    description: "超时时间（秒）"
    min: 1
    max: 300
    
  - name: retries
    type: int
    required: false
    default: 3
    description: "失败重试次数"
    min: 0
    max: 10
    
  - name: collect_interval
    type: int
    required: false
    default: 60
    description: "采集间隔（秒）"
    min: 10

# 预定义指标（可选，用于 UI 展示）
metrics:
  - name: cpu_usage
    description: "CPU 使用率"
    type: gauge
    unit: percent
    
  - name: memory_usage
    description: "内存使用率"
    type: gauge
    unit: percent
    
  - name: disk_usage
    description: "磁盘使用率"
    type: gauge
    unit: percent
    
  - name: network_in_bytes
    description: "网络入流量"
    type: counter
    unit: bytes
    
  - name: network_out_bytes
    description: "网络出流量"
    type: counter
    unit: bytes

# 依赖（可选）
dependencies:
  - name: libsnmp
    version: ">=5.8"
    optional: false
```

### 4.3 单元测试

```go
// plugins/my-plugin/my_plugin_test.go
package main

import (
    "context"
    "testing"
    "time"
    
    "github.com/celestial/orbital-sentinels/sdk"
    "github.com/stretchr/testify/assert"
)

func TestMyPlugin_Meta(t *testing.T) {
    plugin := NewPlugin()
    meta := plugin.Meta()
    
    assert.Equal(t, "my-plugin", meta.Name)
    assert.Equal(t, "1.0.0", meta.Version)
}

func TestMyPlugin_Init(t *testing.T) {
    plugin := NewPlugin()
    
    config := map[string]interface{}{
        "timeout": 10,
        "retries": 5,
    }
    
    err := plugin.Init(config)
    assert.NoError(t, err)
}

func TestMyPlugin_ValidateConfig(t *testing.T) {
    plugin := NewPlugin()
    
    tests := []struct {
        name        string
        config      map[string]interface{}
        expectError bool
    }{
        {
            name: "valid config",
            config: map[string]interface{}{
                "host":     "192.168.1.100",
                "port":     8080,
                "username": "admin",
                "password": "password",
            },
            expectError: false,
        },
        {
            name: "missing host",
            config: map[string]interface{}{
                "username": "admin",
                "password": "password",
            },
            expectError: true,
        },
        {
            name: "missing password",
            config: map[string]interface{}{
                "host":     "192.168.1.100",
                "username": "admin",
            },
            expectError: true,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := plugin.ValidateConfig(tt.config)
            if tt.expectError {
                assert.Error(t, err)
            } else {
                assert.NoError(t, err)
            }
        })
    }
}

func TestMyPlugin_Collect(t *testing.T) {
    plugin := NewPlugin()
    plugin.Init(map[string]interface{}{
        "timeout": 30,
        "retries": 3,
    })
    
    task := &sdk.CollectionTask{
        TaskID:   "test-task-1",
        DeviceID: "test-device-1",
        DeviceConfig: map[string]interface{}{
            "host":     "localhost",
            "port":     8080,
            "username": "admin",
            "password": "password",
        },
        Timeout: 30 * time.Second,
    }
    
    ctx := context.Background()
    metrics, err := plugin.Collect(ctx, task)
    
    assert.NoError(t, err)
    assert.NotEmpty(t, metrics)
    
    // 验证指标
    for _, m := range metrics {
        assert.NotEmpty(t, m.Name)
        assert.NotZero(t, m.Timestamp)
        assert.Contains(t, m.Labels, "device_id")
    }
}

func TestMyPlugin_TestConnection(t *testing.T) {
    plugin := NewPlugin()
    plugin.Init(map[string]interface{}{})
    
    // 测试有效连接
    validConfig := map[string]interface{}{
        "host":     "localhost",
        "port":     8080,
        "username": "admin",
        "password": "password",
    }
    
    err := plugin.TestConnection(validConfig)
    // 根据实际情况判断
    // assert.NoError(t, err)
    _ = err
}
```

## 5. 常用插件示例

### 5.1 SNMP 插件

```go
// plugins/snmp/snmp.go
package main

import (
    "context"
    "fmt"
    "time"
    
    "github.com/gosnmp/gosnmp"
    "github.com/celestial/orbital-sentinels/sdk"
)

type SNMPPlugin struct {
    sdk.BasePlugin
    config *SNMPConfig
}

type SNMPConfig struct {
    Timeout time.Duration
    Retries int
}

func (p *SNMPPlugin) Collect(ctx context.Context, task *sdk.CollectionTask) ([]*sdk.Metric, error) {
    host := task.DeviceConfig["host"].(string)
    community := task.DeviceConfig["community"].(string)
    version := task.DeviceConfig["version"].(string)
    
    // 创建 SNMP 客户端
    client := &gosnmp.GoSNMP{
        Target:    host,
        Port:      161,
        Community: community,
        Version:   p.parseVersion(version),
        Timeout:   p.config.Timeout,
        Retries:   p.config.Retries,
    }
    
    err := client.Connect()
    if err != nil {
        return nil, fmt.Errorf("SNMP connect failed: %w", err)
    }
    defer client.Conn.Close()
    
    metrics := make([]*sdk.Metric, 0)
    
    // 采集 CPU 使用率
    cpuOID := "1.3.6.1.4.1.2021.11.9.0"
    result, err := client.Get([]string{cpuOID})
    if err == nil && len(result.Variables) > 0 {
        if value, ok := result.Variables[0].Value.(int); ok {
            metrics = append(metrics, &sdk.Metric{
                Name:      "cpu_usage",
                Value:     float64(value),
                Timestamp: time.Now().Unix(),
                Labels: map[string]string{
                    "device_id": task.DeviceID,
                    "host":      host,
                },
                Type: sdk.MetricTypeGauge,
            })
        }
    }
    
    // 采集接口流量（表格 OID）
    ifInOID := "1.3.6.1.2.1.2.2.1.10"
    result, err = client.BulkWalk(ifInOID, 10)
    if err == nil {
        for _, variable := range result.Variables {
            if value, ok := variable.Value.(uint64); ok {
                // 提取接口索引
                ifIndex := p.extractIfIndex(variable.Name)
                
                metrics = append(metrics, &sdk.Metric{
                    Name:      "interface_in_bytes",
                    Value:     float64(value),
                    Timestamp: time.Now().Unix(),
                    Labels: map[string]string{
                        "device_id": task.DeviceID,
                        "host":      host,
                        "interface": ifIndex,
                    },
                    Type: sdk.MetricTypeCounter,
                })
            }
        }
    }
    
    return metrics, nil
}

func (p *SNMPPlugin) parseVersion(version string) gosnmp.SnmpVersion {
    switch version {
    case "1":
        return gosnmp.Version1
    case "2c":
        return gosnmp.Version2c
    case "3":
        return gosnmp.Version3
    default:
        return gosnmp.Version2c
    }
}

func (p *SNMPPlugin) extractIfIndex(oid string) string {
    // 从 OID 中提取接口索引
    // 例如: 1.3.6.1.2.1.2.2.1.10.1 -> "1"
    // 简化实现，实际可能需要更复杂的解析
    return oid[len(oid)-1:]
}

func NewPlugin() sdk.Plugin {
    return &SNMPPlugin{}
}
```

### 5.2 HTTP 插件

```go
// plugins/http/http.go
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "time"
    
    "github.com/celestial/orbital-sentinels/sdk"
)

type HTTPPlugin struct {
    sdk.BasePlugin
    client *http.Client
}

func (p *HTTPPlugin) Init(config map[string]interface{}) error {
    timeout := 30 * time.Second
    if t, ok := config["timeout"].(int); ok {
        timeout = time.Duration(t) * time.Second
    }
    
    p.client = &http.Client{
        Timeout: timeout,
    }
    
    return nil
}

func (p *HTTPPlugin) Collect(ctx context.Context, task *sdk.CollectionTask) ([]*sdk.Metric, error) {
    url := task.DeviceConfig["url"].(string)
    method := task.DeviceConfig["method"].(string)
    
    // 创建请求
    req, err := http.NewRequestWithContext(ctx, method, url, nil)
    if err != nil {
        return nil, err
    }
    
    // 添加认证头
    if username, ok := task.DeviceConfig["username"].(string); ok {
        password := task.DeviceConfig["password"].(string)
        req.SetBasicAuth(username, password)
    }
    
    // 发送请求
    resp, err := p.client.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    // 读取响应
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return nil, err
    }
    
    // 解析 JSON 响应
    var data map[string]interface{}
    if err := json.Unmarshal(body, &data); err != nil {
        return nil, err
    }
    
    // 提取指标
    metrics := make([]*sdk.Metric, 0)
    
    // 响应时间
    metrics = append(metrics, &sdk.Metric{
        Name:      "http_response_time",
        Value:     float64(resp.Header.Get("X-Response-Time")), // 示例
        Timestamp: time.Now().Unix(),
        Labels: map[string]string{
            "device_id": task.DeviceID,
            "url":       url,
            "method":    method,
            "status":    fmt.Sprintf("%d", resp.StatusCode),
        },
        Type: sdk.MetricTypeGauge,
    })
    
    // 从响应中提取业务指标
    if value, ok := data["metric_name"].(float64); ok {
        metrics = append(metrics, &sdk.Metric{
            Name:      "custom_metric",
            Value:     value,
            Timestamp: time.Now().Unix(),
            Labels: map[string]string{
                "device_id": task.DeviceID,
            },
            Type: sdk.MetricTypeGauge,
        })
    }
    
    return metrics, nil
}

func NewPlugin() sdk.Plugin {
    return &HTTPPlugin{}
}
```

### 5.3 Modbus 插件

```go
// plugins/modbus/modbus.go
package main

import (
    "context"
    "fmt"
    "time"
    
    "github.com/goburrow/modbus"
    "github.com/celestial/orbital-sentinels/sdk"
)

type ModbusPlugin struct {
    sdk.BasePlugin
}

func (p *ModbusPlugin) Collect(ctx context.Context, task *sdk.CollectionTask) ([]*sdk.Metric, error) {
    host := task.DeviceConfig["host"].(string)
    port := task.DeviceConfig["port"].(int)
    slaveID := byte(task.DeviceConfig["slave_id"].(int))
    
    // 创建 Modbus TCP 客户端
    handler := modbus.NewTCPClientHandler(fmt.Sprintf("%s:%d", host, port))
    handler.SlaveId = slaveID
    handler.Timeout = 10 * time.Second
    
    err := handler.Connect()
    if err != nil {
        return nil, err
    }
    defer handler.Close()
    
    client := modbus.NewClient(handler)
    metrics := make([]*sdk.Metric, 0)
    
    // 读取保持寄存器
    // 假设地址 0-9 存储了 10 个传感器值
    results, err := client.ReadHoldingRegisters(0, 10)
    if err != nil {
        return nil, err
    }
    
    // 解析数据
    for i := 0; i < len(results); i += 2 {
        // 每 2 字节组成一个 16 位值
        value := float64(uint16(results[i])<<8 | uint16(results[i+1]))
        
        metrics = append(metrics, &sdk.Metric{
            Name:      fmt.Sprintf("modbus_register_%d", i/2),
            Value:     value,
            Timestamp: time.Now().Unix(),
            Labels: map[string]string{
                "device_id": task.DeviceID,
                "host":      host,
                "slave_id":  fmt.Sprintf("%d", slaveID),
            },
            Type: sdk.MetricTypeGauge,
        })
    }
    
    return metrics, nil
}

func NewPlugin() sdk.Plugin {
    return &ModbusPlugin{}
}
```

## 6. SDK 帮助函数

```go
// sdk/helpers.go
package sdk

import (
    "crypto/tls"
    "fmt"
    "net/http"
    "time"
)

// BasePlugin 提供基础实现
type BasePlugin struct {
    logger Logger
}

func (bp *BasePlugin) Log() Logger {
    if bp.logger == nil {
        bp.logger = NewDefaultLogger()
    }
    return bp.logger
}

// Logger 日志接口
type Logger interface {
    Debug(args ...interface{})
    Debugf(format string, args ...interface{})
    Info(args ...interface{})
    Infof(format string, args ...interface{})
    Warn(args ...interface{})
    Warnf(format string, args ...interface{})
    Error(args ...interface{})
    Errorf(format string, args ...interface{})
}

// HTTPClientWithRetry 创建支持重试的 HTTP 客户端
func HTTPClientWithRetry(timeout time.Duration, retries int, insecureSkipVerify bool) *http.Client {
    transport := &http.Transport{
        TLSClientConfig: &tls.Config{
            InsecureSkipVerify: insecureSkipVerify,
        },
    }
    
    return &http.Client{
        Timeout:   timeout,
        Transport: transport,
    }
}

// Retry 重试辅助函数
func Retry(attempts int, sleep time.Duration, fn func() error) error {
    var err error
    for i := 0; i < attempts; i++ {
        if err = fn(); err == nil {
            return nil
        }
        time.Sleep(sleep)
        sleep *= 2 // 指数退避
    }
    return fmt.Errorf("after %d attempts, last error: %w", attempts, err)
}

// ConvertToFloat64 类型转换辅助
func ConvertToFloat64(v interface{}) (float64, error) {
    switch val := v.(type) {
    case float64:
        return val, nil
    case float32:
        return float64(val), nil
    case int:
        return float64(val), nil
    case int64:
        return float64(val), nil
    case uint:
        return float64(val), nil
    case uint64:
        return float64(val), nil
    default:
        return 0, fmt.Errorf("cannot convert %T to float64", v)
    }
}

// ValidateRequiredFields 验证必填字段
func ValidateRequiredFields(config map[string]interface{}, requiredFields []string) error {
    for _, field := range requiredFields {
        if _, ok := config[field]; !ok {
            return fmt.Errorf("required field '%s' is missing", field)
        }
    }
    return nil
}
```

## 7. 构建和测试

### 7.1 构建插件
```bash
# 进入插件目录
cd plugins/my-plugin

# 构建为共享库（Go Plugin）
go build -buildmode=plugin -o my-plugin.so

# 或构建为独立程序（gRPC Plugin）
go build -o my-plugin

# 测试插件
go test -v ./...

# 代码检查
golangci-lint run
```

### 7.2 调试插件
```go
// 创建测试程序
// plugins/my-plugin/cmd/test/main.go
package main

import (
    "context"
    "log"
    "time"
    
    plugin "github.com/your/my-plugin"
    "github.com/celestial/orbital-sentinels/sdk"
)

func main() {
    // 创建插件实例
    p := plugin.NewPlugin()
    
    // 初始化
    config := map[string]interface{}{
        "timeout": 30,
        "retries": 3,
    }
    if err := p.Init(config); err != nil {
        log.Fatal(err)
    }
    
    // 测试连接
    deviceConfig := map[string]interface{}{
        "host":     "localhost",
        "port":     8080,
        "username": "admin",
        "password": "password",
    }
    
    if err := p.TestConnection(deviceConfig); err != nil {
        log.Printf("Connection test failed: %v", err)
    } else {
        log.Println("Connection test passed")
    }
    
    // 采集数据
    task := &sdk.CollectionTask{
        TaskID:       "test-1",
        DeviceID:     "test-device",
        DeviceConfig: deviceConfig,
        Timeout:      30 * time.Second,
    }
    
    ctx := context.Background()
    metrics, err := p.Collect(ctx, task)
    if err != nil {
        log.Fatal(err)
    }
    
    log.Printf("Collected %d metrics:", len(metrics))
    for _, m := range metrics {
        log.Printf("  %s = %.2f %v", m.Name, m.Value, m.Labels)
    }
}
```

### 7.3 打包发布
```bash
# 创建发布包
./scripts/package-plugin.sh my-plugin

# 生成的文件
dist/my-plugin-v1.0.0.tar.gz
├── my-plugin.so         # 或 my-plugin (可执行文件)
├── plugin.yaml
├── README.md
└── LICENSE
```

## 8. 最佳实践

### 8.1 错误处理
- 使用 `fmt.Errorf` 包装错误，提供上下文信息
- 区分可重试错误和永久错误
- 记录详细的错误日志

### 8.2 性能优化
- 复用连接（使用连接池）
- 并发采集多个指标
- 批量读取数据
- 设置合理的超时时间

### 8.3 安全考虑
- 不要在日志中输出敏感信息（密码、Token）
- 验证用户输入
- 使用 HTTPS/TLS
- 支持证书验证

### 8.4 资源管理
- 在 `Close()` 方法中释放所有资源
- 使用 `context` 管理生命周期
- 避免内存泄漏

### 8.5 兼容性
- 保持向后兼容
- 版本号遵循语义化版本规范
- 提供迁移指南

## 9. 插件提交

### 9.1 提交到官方仓库
1. Fork 项目
2. 创建插件分支
3. 实现插件
4. 编写文档和测试
5. 提交 Pull Request

### 9.2 检查清单
- [ ] 插件实现完整
- [ ] 配置文件完善
- [ ] 单元测试覆盖率 > 80%
- [ ] README 文档完整
- [ ] 代码通过 lint 检查
- [ ] 遵循代码规范
- [ ] 添加示例配置

### 9.3 文档要求
README.md 应包含:
- 插件功能描述
- 支持的设备类型
- 配置说明
- 使用示例
- 常见问题
- 更新日志

## 10. 常见问题

### Q1: 如何调试插件？
使用独立测试程序，或者在 Sentinel 中启用 debug 日志。

### Q2: 插件如何持久化状态？
可以使用文件、数据库或 Redis 存储状态，建议通过配置指定存储路径。

### Q3: 如何处理大量数据采集？
使用流式处理、分批采集、异步发送。

### Q4: 插件支持热更新吗？
支持，Sentinel 会定期扫描插件目录，自动加载新版本。

### Q5: 如何测试插件性能？
使用 `go test -bench` 进行基准测试，使用 pprof 分析性能瓶颈。

## 11. 参考资源

- [官方文档](https://docs.celestial.io)
- [插件示例](https://github.com/celestial/plugins)
- [社区论坛](https://community.celestial.io)
- [API 参考](https://pkg.go.dev/github.com/celestial/orbital-sentinels/sdk)

