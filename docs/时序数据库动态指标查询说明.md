# 时序数据库动态指标查询说明

## 问题背景

采集端（Sentinel）上报的监控指标名称可能不固定，不同的插件可能使用不同的命名规范：
- 有的用 `cpu_usage`，有的用 `cpu_percent`
- 有的用 `memory_usage`，有的用 `mem_usage`
- 网络指标可能是 `network_in_bytes` 或 `net_bytes_recv`

如果硬编码指标名称，会导致查询不到实际上报的数据。

## 解决方案

### 1. 动态查询所有指标

使用 PromQL 的标签选择器查询设备的所有指标：

```promql
{device_id="dev-12345678"}
```

这个查询会返回该设备所有带 `device_id` 标签的时间序列数据。

### 2. 自动解析指标名称

从查询结果的 `__name__` 标签中获取实际的指标名称：

```go
for _, result := range response.Data.Result {
    metricName := result.Metric["__name__"]
    // 使用实际的指标名称
}
```

### 3. 指标名称映射

为了前端展示的一致性，将不同的指标名称映射到统一的简化名称：

```go
nameMap := map[string]string{
    "cpu_usage":         "cpu",
    "cpu_percent":       "cpu",
    "memory_usage":      "memory",
    "memory_percent":    "memory",
    "disk_usage":        "disk",
    "disk_percent":      "disk",
    "network_in_bytes":  "network_in",
    "network_out_bytes": "network_out",
    "net_bytes_recv":    "network_in",
    "net_bytes_sent":    "network_out",
}
```

## 实现细节

### 查询流程

```
1. 构建通配查询: {device_id="xxx"}
   ↓
2. 执行范围查询: QueryRange()
   ↓
3. 遍历所有时间序列
   ↓
4. 提取指标名称: __name__ 标签
   ↓
5. 简化指标名称: simplifyMetricName()
   ↓
6. 解析时间序列数据
   ↓
7. 返回所有可用指标
```

### 核心代码

```go
// 查询所有指标
allMetricsQuery := fmt.Sprintf(`{device_id="%s"}`, deviceID)
response, err := c.QueryRange(allMetricsQuery, start, end, step)

// 解析每个时间序列
for _, result := range response.Data.Result {
    metricName := result.Metric["__name__"]
    
    // 解析数据点
    data := parseTimeSeries(result.Values)
    
    // 简化名称
    simpleName := c.simplifyMetricName(metricName)
    
    // 添加到结果
    metrics.Metrics[simpleName] = data
}
```

## 优势

### 1. 灵活性
- ✅ 自动发现所有可用指标
- ✅ 不依赖固定的指标名称
- ✅ 支持任意插件上报的指标

### 2. 兼容性
- ✅ 兼容不同的命名规范
- ✅ 通过映射统一前端展示
- ✅ 未映射的指标也能正常显示

### 3. 可扩展性
- ✅ 新增指标无需修改代码
- ✅ 易于添加新的名称映射
- ✅ 支持自定义指标

## 示例

### 场景 1: 标准指标

采集端上报：
```
cpu_usage{device_id="dev-001"} 45.2
memory_usage{device_id="dev-001"} 62.5
```

API 响应：
```json
{
  "metrics": {
    "cpu": {
      "timestamps": ["2024-01-01 00:00:00"],
      "values": [45.2]
    },
    "memory": {
      "timestamps": ["2024-01-01 00:00:00"],
      "values": [62.5]
    }
  }
}
```

### 场景 2: 非标准指标

采集端上报：
```
cpu_percent{device_id="dev-001"} 45.2
mem_usage{device_id="dev-001"} 62.5
```

API 响应：
```json
{
  "metrics": {
    "cpu": {
      "timestamps": ["2024-01-01 00:00:00"],
      "values": [45.2]
    },
    "mem_usage": {
      "timestamps": ["2024-01-01 00:00:00"],
      "values": [62.5]
    }
  }
}
```

### 场景 3: 自定义指标

采集端上报：
```
custom_metric{device_id="dev-001"} 100
business_kpi{device_id="dev-001"} 95.5
```

API 响应：
```json
{
  "metrics": {
    "custom_metric": {
      "timestamps": ["2024-01-01 00:00:00"],
      "values": [100]
    },
    "business_kpi": {
      "timestamps": ["2024-01-01 00:00:00"],
      "values": [95.5]
    }
  }
}
```

## 前端适配

### 1. 优先显示标准指标

前端可以优先显示映射后的标准指标：

```typescript
const standardMetrics = ['cpu', 'memory', 'disk', 'network_in', 'network_out']

// 先显示标准指标
standardMetrics.forEach(metric => {
  if (metrics[metric]) {
    renderChart(metric, metrics[metric])
  }
})

// 再显示其他指标
Object.keys(metrics).forEach(metric => {
  if (!standardMetrics.includes(metric)) {
    renderChart(metric, metrics[metric])
  }
})
```

### 2. 动态创建图表

根据返回的指标动态创建图表：

```typescript
const fetchMetrics = async () => {
  const res = await deviceApi.getDeviceMetrics(deviceId, 24)
  
  // 清空现有图表
  charts.value = []
  
  // 为每个指标创建图表
  Object.entries(res.metrics).forEach(([name, data]) => {
    if (data.values.length > 0) {
      charts.value.push({
        name: formatMetricName(name),
        data: data
      })
    }
  })
}
```

### 3. 指标名称格式化

```typescript
const formatMetricName = (name: string) => {
  const nameMap: Record<string, string> = {
    'cpu': 'CPU 使用率',
    'memory': '内存使用率',
    'disk': '磁盘使用率',
    'network_in': '网络入流量',
    'network_out': '网络出流量'
  }
  
  return nameMap[name] || name
}
```

## 配置建议

### 1. 扩展名称映射

如果有新的指标命名规范，可以在 `simplifyMetricName` 中添加映射：

```go
nameMap := map[string]string{
    // CPU 相关
    "cpu_usage":    "cpu",
    "cpu_percent":  "cpu",
    "cpu_util":     "cpu",
    
    // 内存相关
    "memory_usage":   "memory",
    "memory_percent": "memory",
    "mem_usage":      "memory",
    "mem_percent":    "memory",
    
    // 磁盘相关
    "disk_usage":   "disk",
    "disk_percent": "disk",
    "disk_util":    "disk",
    
    // 网络相关
    "network_in_bytes":  "network_in",
    "network_out_bytes": "network_out",
    "net_bytes_recv":    "network_in",
    "net_bytes_sent":    "network_out",
    "rx_bytes":          "network_in",
    "tx_bytes":          "network_out",
}
```

### 2. 指标过滤

如果需要过滤某些指标，可以添加黑名单：

```go
// 忽略的指标
blacklist := map[string]bool{
    "up":                true,
    "scrape_duration":   true,
    "scrape_samples":    true,
}

if blacklist[metricName] {
    continue
}
```

### 3. 指标分组

可以按类别对指标进行分组：

```go
type MetricCategory struct {
    Name    string
    Metrics map[string]*TimeSeriesData
}

categories := map[string]*MetricCategory{
    "system": {Name: "系统指标"},
    "network": {Name: "网络指标"},
    "custom": {Name: "自定义指标"},
}
```

## 性能考虑

### 1. 查询优化

通配查询可能返回大量数据，可以通过以下方式优化：

```promql
# 只查询特定前缀的指标
{device_id="xxx", __name__=~"cpu.*|memory.*|disk.*"}

# 限制时间范围
{device_id="xxx"}[1h]
```

### 2. 数据采样

对于长时间范围，使用更大的步长：

```go
func (c *Client) calculateStep(hours int) time.Duration {
    switch {
    case hours <= 1:   return 30 * time.Second
    case hours <= 6:   return 1 * time.Minute
    case hours <= 24:  return 5 * time.Minute
    case hours <= 168: return 30 * time.Minute
    default:           return 1 * time.Hour
    }
}
```

### 3. 结果缓存

可以在应用层添加缓存：

```go
type MetricsCache struct {
    data      map[string]*DeviceMetrics
    timestamp map[string]time.Time
    ttl       time.Duration
}
```

## 故障排查

### 问题 1: 查询返回空数据

**检查**:
1. 确认数据已写入时序数据库
2. 检查 `device_id` 标签是否正确
3. 验证时间范围内是否有数据

```bash
# 查询设备所有指标
curl 'http://localhost:8428/api/v1/query?query={device_id="dev-001"}'
```

### 问题 2: 指标名称不符合预期

**检查**:
1. 查看实际上报的指标名称
2. 更新名称映射表
3. 检查前端显示逻辑

### 问题 3: 性能问题

**优化**:
1. 减少查询时间范围
2. 增大采样步长
3. 添加指标过滤
4. 使用缓存

## 总结

动态指标查询方案的优势：

✅ **灵活**: 自动发现所有可用指标  
✅ **兼容**: 支持不同的命名规范  
✅ **可扩展**: 易于添加新指标  
✅ **智能**: 自动映射常见指标名称  
✅ **健壮**: 查询失败不影响系统  

这个方案能够适应各种采集端的指标上报格式，提供更好的用户体验。

