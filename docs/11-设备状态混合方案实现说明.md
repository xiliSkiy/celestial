# 设备状态混合方案实现说明

> 本文档说明设备状态混合方案的实现细节和测试方法。

## 1. 实现概述

### 1.1 方案架构

```
┌─────────────────────────────────────────────────────────────────┐
│ 采集端 (Orbital Sentinel)                                        │
│                                                                  │
│  Scheduler.runTask()                                            │
│    ├─> Plugin.Collect() → 采集指标                              │
│    ├─> createDeviceStatusMetric() → 生成状态指标                │
│    │   └─> device_status{device_id="xxx"} = 1 (online)         │
│    └─> Sender.Send() → 上报所有指标（包含状态指标）             │
└─────────────────────────────────────────────────────────────────┘
                         │
                         │ POST /api/v1/data/ingest
                         │ {metrics: [..., device_status]}
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────┐
│ 中心端 (Gravital Core)                                           │
│                                                                  │
│  ForwarderHandler.IngestMetrics()                               │
│    ├─> extractDeviceStatus() → 提取设备状态                     │
│    │   └─> {dev-xxx: {status: "online", last_seen: now}}       │
│    │                                                             │
│    ├─> updateDeviceStatusInDB() → 更新 PostgreSQL               │
│    │   └─> UPDATE devices SET status='online', last_seen=now   │
│    │                                                             │
│    └─> ForwarderService.IngestMetrics() → 转发到时序库          │
│        └─> VictoriaMetrics 存储 device_status 指标              │
│                                                                  │
│  DeviceMonitor (后台定时任务)                                    │
│    └─> 每 1 分钟检查一次                                         │
│        └─> UPDATE devices SET status='offline'                  │
│            WHERE status='online' AND last_seen < NOW() - 5分钟  │
└─────────────────────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────┐
│ 数据存储                                                         │
│                                                                  │
│  ┌──────────────────┐          ┌──────────────────┐            │
│  │  PostgreSQL      │          │  VictoriaMetrics │            │
│  │                  │          │                  │            │
│  │  devices 表      │          │  device_status   │            │
│  │  ├─ status       │          │  指标（历史）     │            │
│  │  └─ last_seen    │          │                  │            │
│  │                  │          │                  │            │
│  │  用于：           │          │  用于：           │            │
│  │  - 设备列表查询   │          │  - 状态历史分析   │            │
│  │  - 状态筛选      │          │  - 趋势图表      │            │
│  │  - 关联查询      │          │  - 告警规则      │            │
│  └──────────────────┘          └──────────────────┘            │
└─────────────────────────────────────────────────────────────────┘
```

### 1.2 关键特性

1. **双重存储**：
   - PostgreSQL：存储当前状态，用于快速查询
   - VictoriaMetrics：存储状态历史，用于趋势分析

2. **实时更新**：
   - 采集端每次采集后立即上报状态
   - 中心端实时更新 PostgreSQL

3. **兜底机制**：
   - DeviceMonitor 每分钟检查一次
   - 将 5 分钟未上报的设备标记为离线

---

## 2. 代码实现详解

### 2.1 采集端实现

#### 文件：`orbital-sentinels/internal/scheduler/scheduler.go`

**修改点 1：在 runTask 中生成状态指标**

```go
// runTask 运行任务
func (s *Scheduler) runTask(st *ScheduledTask) {
    // ... 执行采集
    metrics, err := p.Collect(taskCtx, st.Task)
    
    // ✅ 新增：生成设备状态指标
    statusMetric := s.createDeviceStatusMetric(st.Task, err)
    if metrics == nil {
        metrics = make([]*plugin.Metric, 0)
    }
    metrics = append(metrics, statusMetric)
    
    // 调用指标处理器（包含状态指标）
    if s.onMetrics != nil {
        s.onMetrics(metrics, st.Task)
    }
}
```

**修改点 2：添加 createDeviceStatusMetric 方法**

```go
// createDeviceStatusMetric 创建设备状态指标
func (s *Scheduler) createDeviceStatusMetric(task *plugin.CollectionTask, collectErr error) *plugin.Metric {
    // 状态值：1=online, 0=offline
    statusValue := 1.0
    if collectErr != nil {
        statusValue = 0.0
    }
    
    return &plugin.Metric{
        Name:      "device_status",
        Value:     statusValue,
        Timestamp: time.Now().UnixMilli(),
        Labels: map[string]string{
            "device_id":   task.DeviceID,
            "device_type": deviceType,
            "task_id":     task.TaskID,
            "plugin":      task.PluginName,
        },
        Type: plugin.MetricTypeGauge,
    }
}
```

### 2.2 中心端实现

#### 文件：`gravital-core/internal/api/handler/forwarder_handler.go`

**修改点 1：IngestMetrics 方法中提取和更新状态**

```go
func (h *ForwarderHandler) IngestMetrics(c *gin.Context) {
    // ... 解析请求
    
    // ✅ 新增：提取设备状态信息并更新 PostgreSQL
    deviceStatusMap := h.extractDeviceStatus(req.Metrics)
    if len(deviceStatusMap) > 0 {
        if err := h.updateDeviceStatusInDB(c.Request.Context(), deviceStatusMap); err != nil {
            h.logger.Error("Failed to update device status", zap.Error(err))
            // 不中断流程，继续转发指标
        }
    }
    
    // 转发指标到时序库（包含设备状态指标）
    if err := h.service.IngestMetrics(c.Request.Context(), req.Metrics); err != nil {
        // ...
    }
}
```

**修改点 2：添加 extractDeviceStatus 方法**

```go
// extractDeviceStatus 从指标中提取设备状态信息
func (h *ForwarderHandler) extractDeviceStatus(metrics []*forwarder.Metric) map[string]DeviceStatusInfo {
    statusMap := make(map[string]DeviceStatusInfo)
    
    for _, m := range metrics {
        // 只处理 device_status 指标
        if m.Name != "device_status" {
            continue
        }
        
        deviceID, ok := m.Labels["device_id"]
        if !ok || deviceID == "" {
            continue
        }
        
        // 解析状态值（1=online, 0=offline）
        status := "offline"
        if m.Value == 1.0 {
            status = "online"
        }
        
        statusMap[deviceID] = DeviceStatusInfo{
            Status:   status,
            LastSeen: time.UnixMilli(m.Timestamp),
        }
    }
    
    return statusMap
}
```

**修改点 3：添加 updateDeviceStatusInDB 方法**

```go
// updateDeviceStatusInDB 更新设备状态到 PostgreSQL
func (h *ForwarderHandler) updateDeviceStatusInDB(ctx context.Context, statusMap map[string]DeviceStatusInfo) error {
    for deviceID, info := range statusMap {
        updates := map[string]interface{}{
            "status":     info.Status,
            "last_seen":  info.LastSeen,
            "updated_at": time.Now(),
        }
        
        result := h.db.WithContext(ctx).
            Model(&model.Device{}).
            Where("device_id = ?", deviceID).
            Updates(updates)
        
        if result.Error != nil {
            h.logger.Error("Failed to update device status",
                zap.String("device_id", deviceID),
                zap.Error(result.Error))
            continue
        }
    }
    
    return nil
}
```

#### 文件：`gravital-core/internal/service/device_monitor.go`（新建）

**完整实现：定时检查设备状态**

```go
type DeviceMonitor struct {
    db             *gorm.DB
    logger         *zap.Logger
    checkInterval  time.Duration // 检查间隔（1 分钟）
    offlineTimeout time.Duration // 离线超时（5 分钟）
    ticker         *time.Ticker
    done           chan struct{}
}

func (m *DeviceMonitor) Start() {
    m.ticker = time.NewTicker(m.checkInterval)
    
    go func() {
        // 立即执行一次检查
        m.checkDeviceStatus()
        
        for {
            select {
            case <-m.ticker.C:
                m.checkDeviceStatus()
            case <-m.done:
                return
            }
        }
    }()
}

func (m *DeviceMonitor) checkDeviceStatus() {
    // 计算超时时间点
    timeoutThreshold := time.Now().Add(-m.offlineTimeout)
    
    // 查找长时间未上报的在线设备
    result := m.db.
        Model(&model.Device{}).
        Where("status = ?", "online").
        Where("last_seen < ? OR last_seen IS NULL", timeoutThreshold).
        Updates(map[string]interface{}{
            "status":     "offline",
            "updated_at": time.Now(),
        })
    
    if result.RowsAffected > 0 {
        m.logger.Info("Marked devices as offline",
            zap.Int64("count", result.RowsAffected))
    }
}
```

#### 文件：`gravital-core/cmd/server/main.go`

**启动 DeviceMonitor**

```go
// 启动设备监控服务
logger.Info("Starting device monitor...")
deviceMonitor := service.NewDeviceMonitor(db, logger.Get(), &service.DeviceMonitorConfig{
    CheckInterval:  1 * time.Minute,
    OfflineTimeout: 5 * time.Minute,
})
deviceMonitor.Start()
logger.Info("Device monitor started")

// ... 优雅关闭时
deviceMonitor.Stop()
```

---

## 3. 测试步骤

### 3.1 准备工作

1. **编译并启动中心端**

```bash
cd gravital-core
go build -o bin/server cmd/server/main.go
./bin/server -c config/config.yaml
```

预期日志：
```
{"level":"INFO","ts":"...","msg":"Starting device monitor..."}
{"level":"INFO","ts":"...","msg":"Device monitor started"}
```

2. **编译并启动采集端**

```bash
cd orbital-sentinels
go build -o bin/sentinel cmd/sentinel/main.go
./bin/sentinel start -c config/config.yaml
```

### 3.2 测试场景 1：设备状态实时更新

**步骤**：

1. 在前端创建一个设备（或使用现有设备）
2. 创建一个采集任务（如 ping 任务）
3. 观察设备状态变化

**预期结果**：

```sql
-- 初始状态
SELECT device_id, name, status, last_seen FROM devices WHERE device_id = 'dev-25422c94';
-- 结果：status = 'unknown', last_seen = NULL

-- 等待采集端执行任务（约 1 分钟）
-- 再次查询
SELECT device_id, name, status, last_seen FROM devices WHERE device_id = 'dev-25422c94';
-- 结果：status = 'online', last_seen = '2025-11-22 10:00:00'
```

**中心端日志**：

```
{"level":"INFO","msg":"Ingested metrics","sentinel_id":"sentinel-xxx","count":5,"devices_updated":1}
{"level":"DEBUG","msg":"Updated device status","device_id":"dev-25422c94","status":"online"}
```

### 3.3 测试场景 2：设备离线检测

**步骤**：

1. 停止采集端（模拟设备离线）

```bash
# 停止采集端
pkill -f sentinel
```

2. 等待 5 分钟以上
3. 查询设备状态

**预期结果**：

```sql
SELECT device_id, name, status, last_seen FROM devices WHERE device_id = 'dev-25422c94';
-- 结果：status = 'offline', last_seen = '2025-11-22 10:00:00'（5分钟前）
```

**中心端日志**：

```
{"level":"INFO","msg":"Marked devices as offline","count":1,"timeout_threshold":"2025-11-22T09:55:00Z"}
```

### 3.4 测试场景 3：设备恢复在线

**步骤**：

1. 重新启动采集端

```bash
./bin/sentinel start -c config/config.yaml
```

2. 等待下一次采集（约 1 分钟）
3. 查询设备状态

**预期结果**：

```sql
SELECT device_id, name, status, last_seen FROM devices WHERE device_id = 'dev-25422c94';
-- 结果：status = 'online', last_seen = '2025-11-22 10:06:00'（刚刚）
```

### 3.5 测试场景 4：时序库查询状态历史

**使用 PromQL 查询**：

```promql
# 查询设备当前状态
device_status{device_id="dev-25422c94"}

# 查询过去 1 小时的状态变化
device_status{device_id="dev-25422c94"}[1h]

# 查询设备在线率（过去 24 小时）
avg_over_time(device_status{device_id="dev-25422c94"}[24h]) * 100

# 查询所有离线设备
device_status == 0
```

**使用 API 查询**：

```bash
# 查询当前状态
curl -X POST http://localhost:8080/api/v1/metrics/query \
  -H "Content-Type: application/json" \
  -d '{
    "query": "device_status{device_id=\"dev-25422c94\"}"
  }'

# 查询历史趋势
curl -X POST http://localhost:8080/api/v1/metrics/query_range \
  -H "Content-Type: application/json" \
  -d '{
    "query": "device_status{device_id=\"dev-25422c94\"}",
    "start": 1700500000,
    "end": 1700510000,
    "step": "60s"
  }'
```

### 3.6 测试场景 5：前端验证

1. **设备列表页面**

访问：`http://localhost:5173/devices`

预期显示：
- 设备状态徽章（绿色=在线，红色=离线，灰色=未知）
- 最后上报时间

2. **设备详情页面**

访问：`http://localhost:5173/devices/{id}`

预期显示：
- 当前状态
- 状态历史图表（如果实现）

---

## 4. 验证清单

### 4.1 功能验证

- [ ] 设备创建后状态为 `unknown`
- [ ] 采集成功后状态变为 `online`
- [ ] 采集失败后状态变为 `offline`
- [ ] 5 分钟未上报后自动标记为 `offline`
- [ ] 恢复采集后状态变回 `online`
- [ ] `last_seen` 字段正确更新
- [ ] 时序库中存储了 `device_status` 指标
- [ ] PromQL 可以查询状态历史

### 4.2 性能验证

- [ ] 设备列表查询速度 < 100ms
- [ ] 状态更新不影响指标转发性能
- [ ] DeviceMonitor 不占用过多 CPU
- [ ] 时序库存储空间增长合理

### 4.3 日志验证

**采集端日志**：
```
{"level":"INFO","msg":"Task succeeded","task_id":"task-xxx","device_id":"dev-xxx","metrics":5}
```

**中心端日志**：
```
{"level":"INFO","msg":"Ingested metrics","sentinel_id":"sentinel-xxx","count":5,"devices_updated":1}
{"level":"DEBUG","msg":"Updated device status","device_id":"dev-xxx","status":"online"}
{"level":"INFO","msg":"Marked devices as offline","count":1}
```

---

## 5. 故障排查

### 5.1 设备状态不更新

**可能原因**：

1. 采集端未生成 `device_status` 指标
   - 检查：查看采集端日志，确认 `metrics` 数量
   - 解决：确认 `createDeviceStatusMetric` 方法被调用

2. 中心端未提取状态信息
   - 检查：查看中心端日志，`devices_updated` 是否 > 0
   - 解决：确认 `extractDeviceStatus` 方法正确解析

3. 数据库更新失败
   - 检查：查看中心端错误日志
   - 解决：检查数据库连接和权限

### 5.2 设备一直显示 offline

**可能原因**：

1. `device_id` 不匹配
   - 检查：确认指标中的 `device_id` 与数据库中的一致
   - 解决：查看日志中的 `device_id`

2. 时间戳问题
   - 检查：确认 `last_seen` 时间是否正确
   - 解决：检查服务器时间同步

### 5.3 DeviceMonitor 不工作

**检查步骤**：

1. 确认 DeviceMonitor 已启动
   ```bash
   # 查看日志
   grep "Device monitor started" logs/app.log
   ```

2. 确认定时任务在执行
   ```bash
   # 查看日志
   grep "Marked devices as offline" logs/app.log
   ```

3. 手动触发检查
   ```sql
   -- 手动将设备标记为离线
   UPDATE devices 
   SET status = 'offline', updated_at = NOW() 
   WHERE status = 'online' 
     AND last_seen < NOW() - INTERVAL '5 minutes';
   ```

---

## 6. 配置说明

### 6.1 DeviceMonitor 配置

在 `gravital-core/cmd/server/main.go` 中：

```go
deviceMonitor := service.NewDeviceMonitor(db, logger.Get(), &service.DeviceMonitorConfig{
    CheckInterval:  1 * time.Minute,  // 检查间隔
    OfflineTimeout: 5 * time.Minute,  // 离线超时
})
```

**建议配置**：

| 场景 | CheckInterval | OfflineTimeout |
|-----|--------------|----------------|
| 开发环境 | 30s | 2min |
| 测试环境 | 1min | 5min |
| 生产环境 | 1min | 5min |
| 高频采集 | 30s | 3min |

### 6.2 采集间隔配置

在创建采集任务时设置 `interval_seconds`：

```json
{
  "device_id": "dev-25422c94",
  "plugin_name": "ping",
  "interval_seconds": 60,  // 1 分钟采集一次
  "timeout_seconds": 30
}
```

**建议**：
- `OfflineTimeout` 应该 > `interval_seconds` × 3
- 例如：采集间隔 60s，离线超时应该 >= 180s（3 分钟）

---

## 7. 性能优化建议

### 7.1 批量更新优化

如果设备数量很多（> 1000），可以优化 `updateDeviceStatusInDB` 方法：

```go
// 使用批量更新
func (h *ForwarderHandler) updateDeviceStatusInDB(ctx context.Context, statusMap map[string]DeviceStatusInfo) error {
    if len(statusMap) == 0 {
        return nil
    }
    
    // 构造批量更新 SQL
    tx := h.db.WithContext(ctx).Begin()
    defer func() {
        if r := recover(); r != nil {
            tx.Rollback()
        }
    }()
    
    for deviceID, info := range statusMap {
        if err := tx.Model(&model.Device{}).
            Where("device_id = ?", deviceID).
            Updates(map[string]interface{}{
                "status":     info.Status,
                "last_seen":  info.LastSeen,
                "updated_at": time.Now(),
            }).Error; err != nil {
            tx.Rollback()
            return err
        }
    }
    
    return tx.Commit().Error
}
```

### 7.2 DeviceMonitor 优化

如果设备数量很多，可以分批处理：

```go
func (m *DeviceMonitor) checkDeviceStatus() {
    timeoutThreshold := time.Now().Add(-m.offlineTimeout)
    
    // 分批处理，每次 100 台设备
    batchSize := 100
    offset := 0
    
    for {
        var devices []model.Device
        result := m.db.
            Where("status = ?", "online").
            Where("last_seen < ?", timeoutThreshold).
            Limit(batchSize).
            Offset(offset).
            Find(&devices)
        
        if result.Error != nil || len(devices) == 0 {
            break
        }
        
        // 批量更新
        deviceIDs := make([]string, len(devices))
        for i, d := range devices {
            deviceIDs[i] = d.DeviceID
        }
        
        m.db.Model(&model.Device{}).
            Where("device_id IN ?", deviceIDs).
            Updates(map[string]interface{}{
                "status":     "offline",
                "updated_at": time.Now(),
            })
        
        offset += batchSize
    }
}
```

---

## 8. 总结

### 8.1 实现的功能

✅ 采集端生成设备状态指标
✅ 中心端实时更新 PostgreSQL
✅ 中心端转发状态指标到时序库
✅ DeviceMonitor 定时检查兜底
✅ 支持状态历史查询和分析

### 8.2 数据流

```
采集 → 状态指标 → 中心端 → PostgreSQL（当前状态）
                          ↘ VictoriaMetrics（历史）
                          
定时检查 → 超时设备 → 标记离线
```

### 8.3 下一步优化

1. 前端增加状态历史图表
2. 配置化 DeviceMonitor 参数
3. 增加状态变更事件通知
4. 实现设备 SLA 统计
5. 优化批量更新性能


