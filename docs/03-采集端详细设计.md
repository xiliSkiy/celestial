# Orbital Sentinels - 采集端详细设计

## 1. 系统架构

### 1.1 整体架构图
```
┌────────────────────────────────────────────────────────────┐
│                  Orbital Sentinel                          │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  ┌──────────────────────────────────────────────────────┐ │
│  │            主控模块 (Main Controller)                │ │
│  │  - 生命周期管理  - 配置管理  - 心跳管理             │ │
│  └────────────┬──────────────────────┬──────────────────┘ │
│               │                      │                     │
│  ┌────────────▼─────────┐  ┌────────▼──────────────────┐ │
│  │   插件管理器          │  │   任务调度器              │ │
│  │  - 插件加载           │  │  - 任务获取               │ │
│  │  - 插件生命周期       │  │  - 定时调度               │ │
│  │  - 插件热更新         │  │  - 并发控制               │ │
│  └────────────┬─────────┘  └────────┬──────────────────┘ │
│               │                      │                     │
│  ┌────────────▼──────────────────────▼──────────────────┐ │
│  │              采集引擎 (Collection Engine)            │ │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐            │ │
│  │  │ Plugin 1 │ │ Plugin 2 │ │ Plugin N │  ...       │ │
│  │  │  (SNMP)  │ │ (Modbus) │ │  (HTTP)  │            │ │
│  │  └──────────┘ └──────────┘ └──────────┘            │ │
│  └────────────┬──────────────────────────────────────┬─┘ │
│               │                                      │   │
│  ┌────────────▼─────────┐  ┌──────────────────────▼───┐ │
│  │   数据处理器          │  │   数据缓冲队列            │ │
│  │  - 数据格式化         │  │  - 本地持久化             │ │
│  │  - 数据聚合           │  │  - 批量发送               │ │
│  │  - 数据过滤           │  │  - 失败重试               │ │
│  └────────────┬─────────┘  └──────────────────────┬───┘ │
│               │                                    │     │
│  ┌────────────▼────────────────────────────────────▼───┐ │
│  │              数据发送器 (Data Sender)               │ │
│  │  ┌──────────────┐ ┌────────────────────────────┐   │ │
│  │  │ 中心端模式    │ │ 直连模式                    │   │ │
│  │  │ → Gravital   │ │ → Prom/VM/ClickHouse       │   │ │
│  │  └──────────────┘ └────────────────────────────┘   │ │
│  └──────────────────────────────────────────────────────┘ │
│                                                            │
└────────────────────────────────────────────────────────────┘
         │                          │
         ▼                          ▼
  ┌──────────────┐          ┌──────────────┐
  │ Gravital Core│          │  Time Series │
  │   (中心端)    │          │   Databases  │
  └──────────────┘          └──────────────┘
         │
         ▼
   ┌──────────────────┐
   │  设备/系统        │
   │ SNMP/Modbus/...  │
   └──────────────────┘
```

## 2. 核心模块详细设计

### 2.1 主控模块

#### 2.1.1 功能描述
- 启动和停止 Sentinel
- 配置加载和热更新
- 心跳管理
- 组件协调
- 信号处理（优雅关闭）

#### 2.1.2 生命周期
```go
// 生命周期状态
type State int

const (
    StateInitializing State = iota  // 初始化
    StateRegistering                // 注册中
    StateRunning                    // 运行中
    StateStopping                   // 停止中
    StateStopped                    // 已停止
    StateError                      // 错误
)

// 主控制器
type MainController struct {
    config      *Config
    state       State
    sentinel    *Sentinel
    pluginMgr   *PluginManager
    scheduler   *TaskScheduler
    sender      *DataSender
    heartbeat   *HeartbeatManager
}

func (m *MainController) Start() error {
    // 1. 初始化
    m.setState(StateInitializing)
    if err := m.initialize(); err != nil {
        return err
    }
    
    // 2. 注册到中心端
    m.setState(StateRegistering)
    if err := m.register(); err != nil {
        return err
    }
    
    // 3. 启动各组件
    m.setState(StateRunning)
    m.startComponents()
    
    // 4. 监听信号
    m.handleSignals()
    
    return nil
}

func (m *MainController) Stop() error {
    m.setState(StateStopping)
    
    // 优雅关闭
    // 1. 停止接受新任务
    m.scheduler.Stop()
    
    // 2. 等待当前任务完成（超时）
    m.waitForTasks(30 * time.Second)
    
    // 3. 刷新缓冲区
    m.sender.Flush()
    
    // 4. 停止插件
    m.pluginMgr.StopAll()
    
    m.setState(StateStopped)
    return nil
}
```

#### 2.1.3 配置管理
```yaml
# config.yaml
sentinel:
  id: ""                           # 留空则自动生成
  name: "sentinel-office-1"
  region: "office-beijing"
  labels:
    env: production
    datacenter: dc1

core:
  url: "https://gravital-core.example.com"
  api_token: "${API_TOKEN}"
  insecure_skip_verify: false

heartbeat:
  interval: 30s                    # 心跳间隔
  timeout: 10s                     # 心跳超时
  retry_times: 3

collector:
  worker_pool_size: 10             # 并发采集数
  task_fetch_interval: 60s         # 任务拉取间隔
  max_execution_time: 300s         # 单个任务最大执行时间

buffer:
  type: "memory"                   # memory, disk
  size: 10000                      # 缓冲区大小
  flush_interval: 10s
  disk_path: "./data/buffer"       # disk 模式下的路径

sender:
  mode: "core"                     # core, direct, hybrid
  batch_size: 1000
  timeout: 30s
  retry_times: 3
  retry_interval: 5s
  
  # 直连模式配置
  direct:
    prometheus:
      enabled: false
      url: "http://prometheus:9090/api/v1/write"
    victoria_metrics:
      enabled: false
      url: "http://victoria:8428/api/v1/write"
    clickhouse:
      enabled: false
      dsn: "tcp://clickhouse:9000/metrics"

plugins:
  directory: "./plugins"
  auto_reload: true
  reload_interval: 300s

logging:
  level: info                      # debug, info, warn, error
  format: json                     # text, json
  output: stdout                   # stdout, file, both
  file_path: "./logs/sentinel.log"
  max_size: 100                    # MB
  max_backups: 7
  max_age: 30                      # days
```

### 2.2 插件管理器

#### 2.2.1 插件接口定义
```go
// plugin/interface.go

// 插件元信息
type PluginMeta struct {
    Name        string   `yaml:"name"`
    Version     string   `yaml:"version"`
    Description string   `yaml:"description"`
    Author      string   `yaml:"author"`
    DeviceTypes []string `yaml:"device_types"`  // 支持的设备类型
}

// 设备字段定义
type DeviceField struct {
    Name        string   `yaml:"name"`
    Type        string   `yaml:"type"`         // string, int, bool, password
    Required    bool     `yaml:"required"`
    Default     interface{} `yaml:"default"`
    Description string   `yaml:"description"`
    Validation  string   `yaml:"validation"`   // 正则表达式
}

// 插件配置 Schema
type PluginSchema struct {
    Meta         PluginMeta    `yaml:"meta"`
    DeviceFields []DeviceField `yaml:"device_fields"`
    ConfigFields []DeviceField `yaml:"config_fields"`  // 插件级配置
}

// 插件接口
type Plugin interface {
    // 获取插件元信息
    Meta() PluginMeta
    
    // 获取配置 Schema
    Schema() PluginSchema
    
    // 初始化插件
    Init(config map[string]interface{}) error
    
    // 验证设备连接配置
    ValidateConfig(deviceConfig map[string]interface{}) error
    
    // 测试连接
    TestConnection(deviceConfig map[string]interface{}) error
    
    // 采集数据
    Collect(ctx context.Context, task *CollectionTask) ([]*Metric, error)
    
    // 关闭插件
    Close() error
}

// 采集任务
type CollectionTask struct {
    TaskID       string
    DeviceID     string
    DeviceConfig map[string]interface{}
    PluginConfig map[string]interface{}
    Timeout      time.Duration
}

// 指标数据
type Metric struct {
    Name      string
    Value     float64
    Timestamp int64
    Labels    map[string]string
    Type      MetricType  // gauge, counter, histogram
}

type MetricType string

const (
    MetricTypeGauge     MetricType = "gauge"
    MetricTypeCounter   MetricType = "counter"
    MetricTypeHistogram MetricType = "histogram"
)
```

#### 2.2.2 插件加载机制
```go
// plugin/manager.go
type PluginManager struct {
    plugins   map[string]Plugin
    directory string
    loader    PluginLoader
}

// 支持两种加载方式
type PluginLoader interface {
    Load(path string) (Plugin, error)
}

// 方式1: Go Plugin (需编译)
type GoPluginLoader struct {}

func (l *GoPluginLoader) Load(path string) (Plugin, error) {
    p, err := plugin.Open(path)
    if err != nil {
        return nil, err
    }
    
    symbol, err := p.Lookup("NewPlugin")
    if err != nil {
        return nil, err
    }
    
    newPlugin, ok := symbol.(func() Plugin)
    if !ok {
        return nil, errors.New("invalid plugin")
    }
    
    return newPlugin(), nil
}

// 方式2: gRPC Plugin (推荐，语言无关)
type GRPCPluginLoader struct {}

// 插件管理器实现
func (m *PluginManager) LoadAll() error {
    files, err := os.ReadDir(m.directory)
    if err != nil {
        return err
    }
    
    for _, file := range files {
        if file.IsDir() {
            pluginPath := filepath.Join(m.directory, file.Name())
            if err := m.LoadPlugin(pluginPath); err != nil {
                log.Errorf("Failed to load plugin %s: %v", file.Name(), err)
                continue
            }
        }
    }
    
    return nil
}

func (m *PluginManager) LoadPlugin(path string) error {
    plugin, err := m.loader.Load(path)
    if err != nil {
        return err
    }
    
    // 初始化插件
    if err := plugin.Init(nil); err != nil {
        return err
    }
    
    meta := plugin.Meta()
    m.plugins[meta.Name] = plugin
    
    log.Infof("Loaded plugin: %s v%s", meta.Name, meta.Version)
    return nil
}

func (m *PluginManager) GetPlugin(name string) (Plugin, bool) {
    plugin, ok := m.plugins[name]
    return plugin, ok
}

func (m *PluginManager) StopAll() {
    for name, plugin := range m.plugins {
        if err := plugin.Close(); err != nil {
            log.Errorf("Failed to close plugin %s: %v", name, err)
        }
    }
}
```

#### 2.2.3 插件配置文件示例
```yaml
# plugins/snmp/plugin.yaml
meta:
  name: "snmp"
  version: "1.0.0"
  description: "SNMP 协议采集插件"
  author: "Celestial Team"
  device_types:
    - switch
    - router
    - firewall

# 设备连接字段定义
device_fields:
  - name: host
    type: string
    required: true
    description: "设备 IP 地址或主机名"
    validation: "^[a-zA-Z0-9.-]+$"
  
  - name: port
    type: int
    required: false
    default: 161
    description: "SNMP 端口"
  
  - name: version
    type: string
    required: false
    default: "2c"
    description: "SNMP 版本 (1, 2c, 3)"
    validation: "^(1|2c|3)$"
  
  - name: community
    type: string
    required: true
    description: "SNMP Community (v1/v2c)"
  
  - name: security_level
    type: string
    required: false
    description: "安全级别 (仅 v3)"
  
  - name: auth_protocol
    type: string
    required: false
    description: "认证协议 (仅 v3)"
  
  - name: auth_password
    type: password
    required: false
    description: "认证密码 (仅 v3)"
  
  - name: priv_protocol
    type: string
    required: false
    description: "加密协议 (仅 v3)"
  
  - name: priv_password
    type: password
    required: false
    description: "加密密码 (仅 v3)"

# 插件级配置
config_fields:
  - name: timeout
    type: int
    required: false
    default: 10
    description: "超时时间（秒）"
  
  - name: retries
    type: int
    required: false
    default: 3
    description: "重试次数"
  
  - name: oids
    type: list
    required: false
    description: "要采集的 OID 列表（留空则采集标准指标）"

# 预定义指标映射
metrics:
  - name: cpu_usage
    oid: "1.3.6.1.4.1.2021.11.9.0"
    type: gauge
    unit: percent
  
  - name: memory_usage
    oid: "1.3.6.1.4.1.2021.4.6.0"
    type: gauge
    unit: percent
  
  - name: interface_in_bytes
    oid: "1.3.6.1.2.1.2.2.1.10"
    type: counter
    unit: bytes
    indexed: true               # 表格 OID
  
  - name: interface_out_bytes
    oid: "1.3.6.1.2.1.2.2.1.16"
    type: counter
    unit: bytes
    indexed: true
```

### 2.3 任务调度器

#### 2.3.1 功能描述
- 从中心端获取采集任务
- 定时调度任务执行
- 并发控制
- 任务执行状态跟踪
- 失败重试

#### 2.3.2 实现
```go
// scheduler/scheduler.go
type TaskScheduler struct {
    core          *CoreClient
    pluginMgr     *PluginManager
    tasks         map[string]*ScheduledTask
    workerPool    *WorkerPool
    fetchInterval time.Duration
    mu            sync.RWMutex
}

type ScheduledTask struct {
    Task         *CollectionTask
    NextRun      time.Time
    Interval     time.Duration
    LastStatus   TaskStatus
    LastError    error
    ExecutionCnt int
}

type TaskStatus string

const (
    TaskStatusPending TaskStatus = "pending"
    TaskStatusRunning TaskStatus = "running"
    TaskStatusSuccess TaskStatus = "success"
    TaskStatusFailed  TaskStatus = "failed"
)

func (s *TaskScheduler) Start(ctx context.Context) {
    // 1. 定期从中心端获取任务
    go s.fetchTasksLoop(ctx)
    
    // 2. 任务调度循环
    go s.scheduleLoop(ctx)
}

func (s *TaskScheduler) fetchTasksLoop(ctx context.Context) {
    ticker := time.NewTicker(s.fetchInterval)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            tasks, err := s.core.GetTasks(ctx)
            if err != nil {
                log.Errorf("Failed to fetch tasks: %v", err)
                continue
            }
            s.updateTasks(tasks)
        case <-ctx.Done():
            return
        }
    }
}

func (s *TaskScheduler) scheduleLoop(ctx context.Context) {
    ticker := time.NewTicker(1 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            now := time.Now()
            s.mu.RLock()
            for _, st := range s.tasks {
                if st.NextRun.Before(now) && st.LastStatus != TaskStatusRunning {
                    s.executeTask(ctx, st)
                }
            }
            s.mu.RUnlock()
        case <-ctx.Done():
            return
        }
    }
}

func (s *TaskScheduler) executeTask(ctx context.Context, st *ScheduledTask) {
    // 提交到工作池
    s.workerPool.Submit(func() {
        s.runTask(ctx, st)
    })
}

func (s *TaskScheduler) runTask(ctx context.Context, st *ScheduledTask) {
    st.LastStatus = TaskStatusRunning
    startTime := time.Now()
    
    // 获取插件
    plugin, ok := s.pluginMgr.GetPlugin(st.Task.PluginName)
    if !ok {
        st.LastStatus = TaskStatusFailed
        st.LastError = fmt.Errorf("plugin not found: %s", st.Task.PluginName)
        return
    }
    
    // 执行采集
    taskCtx, cancel := context.WithTimeout(ctx, st.Task.Timeout)
    defer cancel()
    
    metrics, err := plugin.Collect(taskCtx, st.Task)
    if err != nil {
        st.LastStatus = TaskStatusFailed
        st.LastError = err
        log.Errorf("Task %s failed: %v", st.Task.TaskID, err)
    } else {
        st.LastStatus = TaskStatusSuccess
        st.LastError = nil
        
        // 发送数据
        s.sendMetrics(metrics, st.Task)
    }
    
    // 更新下次执行时间
    st.NextRun = time.Now().Add(st.Interval)
    st.ExecutionCnt++
    
    // 上报执行结果
    s.reportExecution(st, time.Since(startTime), len(metrics))
}

// 工作池
type WorkerPool struct {
    workers   int
    taskQueue chan func()
}

func NewWorkerPool(workers int) *WorkerPool {
    wp := &WorkerPool{
        workers:   workers,
        taskQueue: make(chan func(), workers*2),
    }
    
    for i := 0; i < workers; i++ {
        go wp.worker()
    }
    
    return wp
}

func (wp *WorkerPool) worker() {
    for task := range wp.taskQueue {
        task()
    }
}

func (wp *WorkerPool) Submit(task func()) {
    wp.taskQueue <- task
}
```

### 2.4 数据缓冲队列

#### 2.4.1 功能描述
- 内存缓冲
- 磁盘持久化（可选）
- 批量发送
- 失败重试
- 数据不丢失保证

#### 2.4.2 实现
```go
// buffer/buffer.go

// 缓冲队列接口
type Buffer interface {
    Push(metrics []*Metric) error
    Pop(count int) ([]*Metric, error)
    Size() int
    Close() error
}

// 内存缓冲实现
type MemoryBuffer struct {
    queue    []*Metric
    maxSize  int
    mu       sync.Mutex
    notEmpty *sync.Cond
}

func NewMemoryBuffer(maxSize int) *MemoryBuffer {
    mb := &MemoryBuffer{
        queue:   make([]*Metric, 0, maxSize),
        maxSize: maxSize,
    }
    mb.notEmpty = sync.NewCond(&mb.mu)
    return mb
}

func (mb *MemoryBuffer) Push(metrics []*Metric) error {
    mb.mu.Lock()
    defer mb.mu.Unlock()
    
    // 检查容量
    if len(mb.queue)+len(metrics) > mb.maxSize {
        // 可选策略:
        // 1. 丢弃旧数据
        // 2. 阻塞等待
        // 3. 返回错误
        return fmt.Errorf("buffer full")
    }
    
    mb.queue = append(mb.queue, metrics...)
    mb.notEmpty.Signal()
    
    return nil
}

func (mb *MemoryBuffer) Pop(count int) ([]*Metric, error) {
    mb.mu.Lock()
    defer mb.mu.Unlock()
    
    // 等待数据
    for len(mb.queue) == 0 {
        mb.notEmpty.Wait()
    }
    
    if count > len(mb.queue) {
        count = len(mb.queue)
    }
    
    metrics := mb.queue[:count]
    mb.queue = mb.queue[count:]
    
    return metrics, nil
}

// 磁盘缓冲实现（使用 BadgerDB）
type DiskBuffer struct {
    db      *badger.DB
    counter uint64
}

func NewDiskBuffer(path string) (*DiskBuffer, error) {
    opts := badger.DefaultOptions(path)
    db, err := badger.Open(opts)
    if err != nil {
        return nil, err
    }
    
    return &DiskBuffer{db: db}, nil
}

func (db *DiskBuffer) Push(metrics []*Metric) error {
    return db.db.Update(func(txn *badger.Txn) error {
        for _, metric := range metrics {
            key := fmt.Sprintf("metric_%d", atomic.AddUint64(&db.counter, 1))
            data, _ := json.Marshal(metric)
            if err := txn.Set([]byte(key), data); err != nil {
                return err
            }
        }
        return nil
    })
}

func (db *DiskBuffer) Pop(count int) ([]*Metric, error) {
    metrics := make([]*Metric, 0, count)
    keys := make([][]byte, 0, count)
    
    // 读取
    err := db.db.View(func(txn *badger.Txn) error {
        opts := badger.DefaultIteratorOptions
        it := txn.NewIterator(opts)
        defer it.Close()
        
        for it.Rewind(); it.Valid() && len(metrics) < count; it.Next() {
            item := it.Item()
            key := item.KeyCopy(nil)
            
            err := item.Value(func(val []byte) error {
                var metric Metric
                if err := json.Unmarshal(val, &metric); err != nil {
                    return err
                }
                metrics = append(metrics, &metric)
                keys = append(keys, key)
                return nil
            })
            
            if err != nil {
                return err
            }
        }
        return nil
    })
    
    if err != nil {
        return nil, err
    }
    
    // 删除已读取的
    err = db.db.Update(func(txn *badger.Txn) error {
        for _, key := range keys {
            if err := txn.Delete(key); err != nil {
                return err
            }
        }
        return nil
    })
    
    return metrics, err
}
```

### 2.5 数据发送器

#### 2.5.1 功能描述
- 支持多种发送模式（中心端、直连、混合）
- 批量发送
- 失败重试（指数退避）
- 熔断保护
- 数据压缩

#### 2.5.2 实现
```go
// sender/sender.go
type DataSender struct {
    mode     SendMode
    buffer   buffer.Buffer
    core     *CoreSender
    direct   *DirectSender
    metrics  *SenderMetrics
}

type SendMode string

const (
    SendModeCore   SendMode = "core"    // 发送到中心端
    SendModeDirect SendMode = "direct"  // 直连数据库
    SendModeHybrid SendMode = "hybrid"  // 混合模式
)

func (s *DataSender) Start(ctx context.Context) {
    ticker := time.NewTicker(s.config.FlushInterval)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            s.flush(ctx)
        case <-ctx.Done():
            s.flush(ctx) // 最后一次刷新
            return
        }
    }
}

func (s *DataSender) flush(ctx context.Context) {
    metrics, err := s.buffer.Pop(s.config.BatchSize)
    if err != nil || len(metrics) == 0 {
        return
    }
    
    switch s.mode {
    case SendModeCore:
        s.sendToCore(ctx, metrics)
    case SendModeDirect:
        s.sendDirect(ctx, metrics)
    case SendModeHybrid:
        s.sendHybrid(ctx, metrics)
    }
}

// 发送到中心端
func (s *DataSender) sendToCore(ctx context.Context, metrics []*Metric) {
    if err := s.core.Send(ctx, metrics); err != nil {
        log.Errorf("Failed to send to core: %v", err)
        // 重新放回缓冲区
        s.buffer.Push(metrics)
        s.metrics.FailedCount.Add(int64(len(metrics)))
        return
    }
    s.metrics.SuccessCount.Add(int64(len(metrics)))
}

// 直连发送
func (s *DataSender) sendDirect(ctx context.Context, metrics []*Metric) {
    if err := s.direct.Send(ctx, metrics); err != nil {
        log.Errorf("Failed to send direct: %v", err)
        s.buffer.Push(metrics)
        s.metrics.FailedCount.Add(int64(len(metrics)))
        return
    }
    s.metrics.SuccessCount.Add(int64(len(metrics)))
}

// 混合模式：实时数据直连，元数据发中心端
func (s *DataSender) sendHybrid(ctx context.Context, metrics []*Metric) {
    // 分离实时指标和元数据
    realtime, metadata := s.splitMetrics(metrics)
    
    var wg sync.WaitGroup
    wg.Add(2)
    
    // 并发发送
    go func() {
        defer wg.Done()
        s.sendDirect(ctx, realtime)
    }()
    
    go func() {
        defer wg.Done()
        s.sendToCore(ctx, metadata)
    }()
    
    wg.Wait()
}

// CoreSender: 发送到中心端
type CoreSender struct {
    client     *http.Client
    url        string
    token      string
    compressor Compressor
    breaker    *CircuitBreaker
}

func (cs *CoreSender) Send(ctx context.Context, metrics []*Metric) error {
    // 熔断检查
    if !cs.breaker.Allow() {
        return errors.New("circuit breaker open")
    }
    
    // 序列化
    data, err := json.Marshal(map[string]interface{}{
        "metrics": metrics,
    })
    if err != nil {
        return err
    }
    
    // 压缩
    compressed, err := cs.compressor.Compress(data)
    if err != nil {
        return err
    }
    
    // 发送 HTTP 请求
    req, err := http.NewRequestWithContext(ctx, "POST", cs.url, bytes.NewReader(compressed))
    if err != nil {
        return err
    }
    
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Content-Encoding", "gzip")
    req.Header.Set("Authorization", "Bearer "+cs.token)
    
    resp, err := cs.client.Do(req)
    if err != nil {
        cs.breaker.RecordFailure()
        return err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        cs.breaker.RecordFailure()
        return fmt.Errorf("unexpected status: %d", resp.StatusCode)
    }
    
    cs.breaker.RecordSuccess()
    return nil
}

// DirectSender: 直连时序数据库
type DirectSender struct {
    prometheus *PrometheusWriter
    victoria   *VictoriaMetricsWriter
    clickhouse *ClickHouseWriter
}

func (ds *DirectSender) Send(ctx context.Context, metrics []*Metric) error {
    var wg sync.WaitGroup
    errors := make(chan error, 3)
    
    if ds.prometheus != nil {
        wg.Add(1)
        go func() {
            defer wg.Done()
            if err := ds.prometheus.Write(ctx, metrics); err != nil {
                errors <- err
            }
        }()
    }
    
    if ds.victoria != nil {
        wg.Add(1)
        go func() {
            defer wg.Done()
            if err := ds.victoria.Write(ctx, metrics); err != nil {
                errors <- err
            }
        }()
    }
    
    if ds.clickhouse != nil {
        wg.Add(1)
        go func() {
            defer wg.Done()
            if err := ds.clickhouse.Write(ctx, metrics); err != nil {
                errors <- err
            }
        }()
    }
    
    wg.Wait()
    close(errors)
    
    // 收集错误
    var errs []error
    for err := range errors {
        errs = append(errs, err)
    }
    
    if len(errs) > 0 {
        return fmt.Errorf("failed to send: %v", errs)
    }
    
    return nil
}

// 熔断器
type CircuitBreaker struct {
    maxFailures  int
    resetTimeout time.Duration
    state        CircuitState
    failures     int
    lastFailTime time.Time
    mu           sync.Mutex
}

type CircuitState int

const (
    StateClosed CircuitState = iota
    StateOpen
    StateHalfOpen
)

func (cb *CircuitBreaker) Allow() bool {
    cb.mu.Lock()
    defer cb.mu.Unlock()
    
    switch cb.state {
    case StateClosed:
        return true
    case StateOpen:
        // 检查是否可以尝试恢复
        if time.Since(cb.lastFailTime) > cb.resetTimeout {
            cb.state = StateHalfOpen
            return true
        }
        return false
    case StateHalfOpen:
        return true
    }
    
    return false
}

func (cb *CircuitBreaker) RecordSuccess() {
    cb.mu.Lock()
    defer cb.mu.Unlock()
    
    cb.failures = 0
    cb.state = StateClosed
}

func (cb *CircuitBreaker) RecordFailure() {
    cb.mu.Lock()
    defer cb.mu.Unlock()
    
    cb.failures++
    cb.lastFailTime = time.Now()
    
    if cb.failures >= cb.maxFailures {
        cb.state = StateOpen
    }
}
```

### 2.6 心跳管理

#### 2.6.1 实现
```go
// heartbeat/heartbeat.go
type HeartbeatManager struct {
    core     *CoreClient
    interval time.Duration
    timeout  time.Duration
    metrics  *SystemMetrics
}

func (hm *HeartbeatManager) Start(ctx context.Context) {
    ticker := time.NewTicker(hm.interval)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            hm.sendHeartbeat(ctx)
        case <-ctx.Done():
            return
        }
    }
}

func (hm *HeartbeatManager) sendHeartbeat(ctx context.Context) {
    ctx, cancel := context.WithTimeout(ctx, hm.timeout)
    defer cancel()
    
    // 收集系统指标
    metrics := hm.metrics.Collect()
    
    // 发送心跳
    resp, err := hm.core.SendHeartbeat(ctx, &HeartbeatRequest{
        SentinelID:   GetSentinelID(),
        CPUUsage:     metrics.CPUUsage,
        MemoryUsage:  metrics.MemoryUsage,
        DiskUsage:    metrics.DiskUsage,
        TaskCount:    metrics.TaskCount,
        PluginCount:  metrics.PluginCount,
        UptimeSeconds: metrics.UptimeSeconds,
    })
    
    if err != nil {
        log.Errorf("Failed to send heartbeat: %v", err)
        return
    }
    
    // 处理响应（可能包含配置更新）
    if resp.ConfigVersion > GetCurrentConfigVersion() {
        hm.handleConfigUpdate(resp.ConfigVersion)
    }
}

// 系统指标收集
type SystemMetrics struct {
    startTime time.Time
}

func (sm *SystemMetrics) Collect() *Metrics {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    
    return &Metrics{
        CPUUsage:      getCPUUsage(),
        MemoryUsage:   float64(m.Alloc) / float64(m.Sys) * 100,
        DiskUsage:     getDiskUsage(),
        TaskCount:     getTaskCount(),
        PluginCount:   getPluginCount(),
        UptimeSeconds: int64(time.Since(sm.startTime).Seconds()),
    }
}
```

## 3. 项目结构

```
orbital-sentinels/
├── cmd/
│   └── sentinel/
│       └── main.go
├── internal/
│   ├── agent/                    # 主控模块
│   │   ├── controller.go
│   │   ├── config.go
│   │   └── lifecycle.go
│   ├── plugin/                   # 插件管理
│   │   ├── interface.go          # 插件接口
│   │   ├── manager.go
│   │   ├── loader.go
│   │   └── schema.go
│   ├── scheduler/                # 任务调度
│   │   ├── scheduler.go
│   │   ├── task.go
│   │   └── worker_pool.go
│   ├── buffer/                   # 数据缓冲
│   │   ├── buffer.go
│   │   ├── memory.go
│   │   └── disk.go
│   ├── sender/                   # 数据发送
│   │   ├── sender.go
│   │   ├── core.go               # 中心端发送器
│   │   ├── direct.go             # 直连发送器
│   │   ├── prometheus.go
│   │   ├── victoria.go
│   │   └── clickhouse.go
│   ├── heartbeat/                # 心跳管理
│   │   ├── heartbeat.go
│   │   └── metrics.go
│   ├── client/                   # 中心端客户端
│   │   └── core_client.go
│   └── pkg/                      # 公共包
│       ├── logger/
│       ├── compressor/
│       ├── breaker/
│       └── retry/
├── plugins/                      # 插件目录
│   ├── snmp/
│   │   ├── plugin.yaml
│   │   ├── snmp.go
│   │   └── README.md
│   ├── modbus/
│   │   ├── plugin.yaml
│   │   ├── modbus.go
│   │   └── README.md
│   ├── http/
│   │   ├── plugin.yaml
│   │   ├── http.go
│   │   └── README.md
│   ├── ping/
│   │   ├── plugin.yaml
│   │   ├── ping.go
│   │   └── README.md
│   └── ...
├── sdk/                          # 插件开发 SDK
│   ├── plugin_base.go
│   ├── helpers.go
│   └── examples/
├── config/
│   ├── config.yaml
│   └── config.example.yaml
├── scripts/
│   ├── build.sh
│   ├── build-plugins.sh
│   └── install.sh
├── Dockerfile
└── README.md
```

## 4. 部署和运维

### 4.1 安装部署
```bash
# 下载二进制
wget https://releases.celestial.io/sentinel/v1.0.0/sentinel-linux-amd64.tar.gz
tar -xzf sentinel-linux-amd64.tar.gz
cd sentinel

# 编辑配置
vi config/config.yaml

# 注册到中心端
./sentinel register --core-url https://gravital-core.example.com --name sentinel-01

# 启动
./sentinel start

# 或使用 systemd
sudo cp sentinel.service /etc/systemd/system/
sudo systemctl enable sentinel
sudo systemctl start sentinel
```

### 4.2 Systemd 服务
```ini
# sentinel.service
[Unit]
Description=Celestial Orbital Sentinel
After=network.target

[Service]
Type=simple
User=sentinel
WorkingDirectory=/opt/sentinel
ExecStart=/opt/sentinel/sentinel start
ExecStop=/opt/sentinel/sentinel stop
Restart=on-failure
RestartSec=10s

[Install]
WantedBy=multi-user.target
```

### 4.3 Docker 部署
```dockerfile
# Dockerfile
FROM golang:1.21 AS builder
WORKDIR /app
COPY . .
RUN go mod download
RUN CGO_ENABLED=0 go build -o sentinel ./cmd/sentinel

# 构建插件
RUN cd plugins/snmp && go build -buildmode=plugin -o snmp.so
RUN cd plugins/modbus && go build -buildmode=plugin -o modbus.so

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/sentinel .
COPY --from=builder /app/plugins ./plugins
COPY --from=builder /app/config ./config
CMD ["./sentinel", "start"]
```

### 4.4 监控指标
```yaml
# Sentinel 自身监控指标
sentinel_info{version, os, arch}
sentinel_uptime_seconds
sentinel_tasks_total
sentinel_tasks_success_total
sentinel_tasks_failed_total
sentinel_task_duration_seconds
sentinel_plugins_loaded
sentinel_buffer_size
sentinel_buffer_usage_percent
sentinel_sent_metrics_total
sentinel_sent_bytes_total
sentinel_send_errors_total
sentinel_heartbeat_success_total
sentinel_heartbeat_failed_total
sentinel_cpu_usage_percent
sentinel_memory_usage_bytes
sentinel_goroutines
```

## 5. 插件开发指南

详见 `04-插件开发指南.md`

## 6. 安全考虑

### 6.1 通信安全
- 强制 HTTPS
- API Token 认证
- 证书双向认证（可选）

### 6.2 敏感信息保护
- 密码加密存储
- 配置文件权限控制（600）
- 内存中的敏感信息使用后清零

### 6.3 运行权限
- 使用非 root 用户运行
- 最小权限原则
- 插件沙箱隔离（可选）

## 7. 性能优化

### 7.1 并发控制
- 工作池限制并发数
- 任务优先级队列
- 背压机制

### 7.2 资源控制
- 内存限制（GOMEMLIMIT）
- 协程数量监控
- 文件描述符管理

### 7.3 网络优化
- HTTP 连接复用
- 批量发送
- 数据压缩
- 请求合并

